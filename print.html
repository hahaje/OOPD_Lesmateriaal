<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Object-Oriented Program Development</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="les 01 lesprogramma.html"><strong aria-hidden="true">1.</strong> Les 01 Lesprogramma</a></li><li class="chapter-item expanded "><a href="les 02 voorbereiding.html"><strong aria-hidden="true">2.</strong> Les 02 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 02 lesprogramma.html"><strong aria-hidden="true">3.</strong> Les 02 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 03 voorbereiding.html"><strong aria-hidden="true">4.</strong> Les 03 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 03 lesprogramma.html"><strong aria-hidden="true">5.</strong> Les 03 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 04 voorbereiding.html"><strong aria-hidden="true">6.</strong> Les 04 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 04 lesprogramma.html"><strong aria-hidden="true">7.</strong> Les 04 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 05 voorbereiding.html"><strong aria-hidden="true">8.</strong> Les 05 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 05 lesprogramma.html"><strong aria-hidden="true">9.</strong> Les 05 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 06 voorbereiding.html"><strong aria-hidden="true">10.</strong> Les 06 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 06 lesprogramma.html"><strong aria-hidden="true">11.</strong> Les 06 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 07 voorbereiding.html"><strong aria-hidden="true">12.</strong> Les 07 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 07 lesprogramma.html"><strong aria-hidden="true">13.</strong> Les 07 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 08 voorbereiding.html"><strong aria-hidden="true">14.</strong> Les 08 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 08 lesprogramma.html"><strong aria-hidden="true">15.</strong> Les 08 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 09 voorbereiding.html"><strong aria-hidden="true">16.</strong> Les 09 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 09 lesprogramma.html"><strong aria-hidden="true">17.</strong> Les 09 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 10 voorbereiding.html"><strong aria-hidden="true">18.</strong> Les 10 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 10 lesprogramma.html"><strong aria-hidden="true">19.</strong> Les 10 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 11 voorbereiding.html"><strong aria-hidden="true">20.</strong> Les 11 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 11 lesprogramma.html"><strong aria-hidden="true">21.</strong> Les 11 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 12 voorbereiding.html"><strong aria-hidden="true">22.</strong> Les 12 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 12 lesprogramma.html"><strong aria-hidden="true">23.</strong> Les 12 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 13 voorbereiding.html"><strong aria-hidden="true">24.</strong> Les 13 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 13 lesprogramma.html"><strong aria-hidden="true">25.</strong> Les 13 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 14 voorbereiding.html"><strong aria-hidden="true">26.</strong> Les 14 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 14 lesprogramma.html"><strong aria-hidden="true">27.</strong> Les 14 Lespogramma</a></li><li class="chapter-item expanded "><a href="les 15 voorbereiding.html"><strong aria-hidden="true">28.</strong> Les 15 Voorbereiding</a></li><li class="chapter-item expanded "><a href="les 15 lesprogramma.html"><strong aria-hidden="true">29.</strong> Les 15 Lespogramma</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Object-Oriented Program Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="les-1---lesprogramma-l1"><a class="header" href="#les-1---lesprogramma-l1">Les 1 - Lesprogramma (L1)</a></h1>
<h1 id="opgave-l11---delen"><a class="header" href="#opgave-l11---delen">Opgave L1.1 - Delen</a></h1>
<p><em>Individueel, programmeervaardigheid</em></p>
<h2 id="l11-a"><a class="header" href="#l11-a">L1.1 A</a></h2>
<p>Wanneer je twee gehele getallen door elkaar deelt, krijg je niet automatisch een kommagetal, terwijl dat soms wel wenselijk is.</p>
<p>Bijvoorbeeld: </p>
<p><code>println(5 / 2);</code> </p>
<p>levert 2 op, terwijl het handig kan zijn dat er 2.5 uit zou komen.
Maak een functie, <code>floatDelen</code>, die twee gehele getallen heeft als invoer. De functie deelt het eerste getal door het tweede getal en retourneert het resultaat als een kommagetal.</p>
<h2 id="l11-b"><a class="header" href="#l11-b">L1.1 B</a></h2>
<p>Test het programma door in het hoofdprogramma de functie een paar keer aan te roepen, het resultaat naar het scherm te schrijven en te kijken of het resultaat op het scherm overeen komt met het resultaat dat je verwacht.</p>
<p><em>Tags: datatypes, testen, methodeaanroep &lt;&gt; methodedefinitie, parameters, argumenten, returnwaarden, functie, methode</em></p>
<h1 id="opgave-l12---globaal-delen"><a class="header" href="#opgave-l12---globaal-delen">Opgave L1.2 - Globaal delen</a></h1>
<p><em>Klassikaal, discussie, begrip</em></p>
<p>Gegeven onderstaande oplossing:</p>
<pre><code class="language-java">int getal1, getal2;
float resultaat;
void setup() {
   getal1 = 5;
   getal2 = 2;

   floatDelen();
   println(resultaat);
}

void floatDelen() {
   float f1 = (float)getal1;
   float f2 = (float)getal2;

   resultaat = f1 / f2;
}
</code></pre>
<p>Bovenstaande oplossing werkt wel, maar is niet ideaal. Geef een nadeel van deze uitwerking.</p>
<p><em>Tags: globale variabelen &lt;&gt; lokale variabelen, returnwaarden, parameters, argumenten</em></p>
<h1 id="opgave-l13---delen-door-nul"><a class="header" href="#opgave-l13---delen-door-nul">Opgave L1.3 - Delen door nul</a></h1>
<p><em>Klassikaal, discussie, begrip</em></p>
<p>Onderstaande programma's veroorzaken drie verschillende foutmeldingen:</p>
<h2 id="l13-a"><a class="header" href="#l13-a">L1.3 A</a></h2>
<pre><code class="language-java">void setup() {
   println(floatDelen(5, 2);
}
</code></pre>
<h2 id="l13-b"><a class="header" href="#l13-b">L1.3 B</a></h2>
<pre><code class="language-java">void setup() {
   println(floatDelen(5, 2.0));
}
</code></pre>
<h2 id="l13-c"><a class="header" href="#l13-c">L1.3 C</a></h2>
<pre><code class="language-java">void setup() {
   println(1 / 0);
}
</code></pre>
<p>Hoewel er drie verschillende fouten worden veroorzaakt, kun je deze drie fouten in twee [soorten]{.ul} onderverdelen. Welke twee fouten horen bij dezelfde soort en welke fout is van de andere soort. Waarom kies je voor deze indeling?
Verzin een passende naam voor beide soorten foutmelding</p>
<p><em>Tags: runtime, delen door 0, syntax, compile-time, datatypes, statische types</em></p>
<h1 id="opgave-l14---zoeken-in-een-array"><a class="header" href="#opgave-l14---zoeken-in-een-array">Opgave L1.4 - Zoeken in een array</a></h1>
<p><em>Individueel, programmeervaardigheid</em></p>
<p>De functie <code>komtGetalVoorIn(int getal, int[] lijst)</code> retourneert true als <code>getal</code> voorkomt in <code>lijst</code>. Als <code>getal</code> niet voorkomt in <code>lijst</code>, dan wordt er <code>false</code> geretourneerd.</p>
<h2 id="l14-a"><a class="header" href="#l14-a">L1.4 A</a></h2>
<p>Maak eerst een programma waarmee je de functie <code>komtGetalVoorIn</code> kunt testen:</p>
<ol>
<li>Verzin waarden voor de twee parameters van de functie waarvan je de uitkomst van de functieaanroep uit het hoofd kunt bepalen.</li>
<li>Roep de functie aan in <code>setup</code> van processing (zonder de functie te definiëren).</li>
<li>Schrijf het resultaat van deze functieaanroep naar de console en controleer of je de foutmelding krijgt die aangeeft dat de functie nog niet bestaat.</li>
</ol>
<h2 id="l14-b"><a class="header" href="#l14-b">L1.4 B</a></h2>
<p>Implementeer de functie <code>komtGetalVoorIn</code> en controleer of het testresultaat overeenkomt met wat je verwacht.</p>
<h2 id="l14-c"><a class="header" href="#l14-c">L1.4 C</a></h2>
<p><em>Klassikaal, testen</em></p>
<p>Wanneer is een test goed?</p>
<p><em>Tags: testen (eerst), array, testen, methodeaanroep &lt;&gt; methodedefinitie, return</em></p>
<h1 id="opgave-l15---doefunctie"><a class="header" href="#opgave-l15---doefunctie">Opgave L1.5 - doeFunctie</a></h1>
<p><em>Klassikaal, codebegrip</em></p>
<p>Gegeven onderstaande code waarin een functie voorkomt met een onbruikbare functienaam.</p>
<pre><code class="language-java">int[][] hetVeld = {
   {1, 6, 3},
   {3, 2, 9},
   };

void setup() {
   println(doeFunctie(hetVeld, 1));
}

int doeFunctie(int[][] a, int b) {
   int c = 0;
   int[] d = a[b];
   for (int i = 0; i &lt; d.length; i++) {
      c += d[i];
   }

   return c;
}
</code></pre>
<h2 id="l15-a"><a class="header" href="#l15-a">L1.5 A</a></h2>
<p>Loop de functie, <code>doeFunctie</code>, regel voor regel door en houd bij welke variabelen er zijn en wat de waarde van elke variabele is (in feite speel je nu zelf de runtime omgeving na). Probeer er op deze manier te achter te komen wat de functie doet.</p>
<h2 id="l15-b"><a class="header" href="#l15-b">L1.5 B</a></h2>
<p>Verander in de aanroep van <code>doeFunctie</code> het tweede argument in 2 (ipv 1). Welk soort foutmelding krijg je nu? Wat betekent de foutmelding?</p>
<h2 id="l15-c"><a class="header" href="#l15-c">L1.5 C</a></h2>
<p>Als je de variabele a, b, c of d zou aanroepen in setup, dan gaat dit mis. Andersom (<code>hetVeld</code> aanroepen in <code>doeFunctie</code>) gaat wel goed. Hoe komt dit? Geef in de runtime administratie die je bij opgave A hebt gemaakt aan welke variabelen bij welke functie horen.</p>
<h2 id="l15-d"><a class="header" href="#l15-d">L1.5 D</a></h2>
<p>Bedenk betere namen voor de functie en variabelen, zodat meteen duidelijk wordt wat de functie doet zonder 'de runtime omgeving na te spelen'</p>
<p><em>Tags: runtime &lt;&gt; compile-time, stap voor stap doorlopen, runtime administratie, runtime omgeving, ArrayIndexOutOfBoundsException, Exception, locale variabele</em> </p>
<h1 id="opgave-l16---doekeertwee"><a class="header" href="#opgave-l16---doekeertwee">Opgave L1.6 - doeKeerTwee</a></h1>
<p><em>Tweetallen, begrip</em></p>
<pre><code class="language-java">int testGetal = 5;
int[] testGetallen = {5, 5};

void setup() {
   doeKeerTwee(testGetal);
   doeKeerTwee(testGetallen);

   println(testGetal);
   println(testGetallen);
}

void doeKeerTwee(int getal) {
   getal = 2 * getal;
}

void doeKeerTwee(int[] getallen) {
   for (int i = 0; i &lt; getallen.length; i++) {
      getallen[i] = 2 * getallen[i];
   }
}
</code></pre>
<p>Voer dit programma uit en bekijk de uitvoer. Vergelijk de waarde van het <code>testGetal</code> met de waarde in <code>testGetallen</code>. Wat is het belangrijkste verschil?</p>
<p>In de eerstvolgende les besteden we aandacht aan dit verschil.</p>
<p><em>Tags: referentietypes, primitieve types, runtime administratie, overloading</em></p>
<h1 id="extra-oefeningen"><a class="header" href="#extra-oefeningen">Extra Oefeningen</a></h1>
<h1 id="opgave-l17-arrays-bouwen"><a class="header" href="#opgave-l17-arrays-bouwen">Opgave L1.7 Arrays bouwen</a></h1>
<p><em>Programmeervaardigheid</em></p>
<h2 id="l17-a---getallen-uit-twee-arrays-bij-elkaar-optellen"><a class="header" href="#l17-a---getallen-uit-twee-arrays-bij-elkaar-optellen">L1.7 A - getallen uit twee arrays bij elkaar optellen</a></h2>
<p>Maak de methode <code>telElementenOp</code> die twee integer arrays als invoer heeft. De methode telt de getallen van elk element uit beide arrays bij elkaar op en slaat de resultaten op in een nieuwe array. Vervolgens retourneert de methode de nieuwe array.</p>
<p>Test deze methode in de setup-methode van processing.</p>
<p><em>Hint: ga ervan uit dat beide arrays altijd dezelfde lengte hebben</em></p>
<p><strong>Startcode</strong>:</p>
<pre><code class="language-java">int[] lijst1 = {1, 2, 3};
int[] lijst2 = {6, 4, 7};
void setup() {
   println(telElementenOp(lijst1, lijst2));
}
//hieronder jouw implementatie van de methode
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-java">[0] 7
[1] 6
[2] 10
</code></pre>
<h2 id="l17-b---maximum-bepalen-van-twee-arrays"><a class="header" href="#l17-b---maximum-bepalen-van-twee-arrays">L1.7 B - maximum bepalen van twee arrays</a></h2>
<p>Maak de methode <code>maakMaxArray</code>. Deze methode krijgt twee arrays als invoer, bepaalt de methode per element uit beide arrays het getal met de hoogste waarde en retourneert een nieuwe array met deze getallen.</p>
<p>Als één van beide arrays langer is dan de ander, dan moet het resultaat aangevuld worden met de elementen uit de langste array.</p>
<p>Test deze methode in de setup-methode van processing.</p>
<p><strong>Startcode</strong>:</p>
<pre><code class="language-java">int[] lijst1 = {1, 2, 3};
int[] lijst2 = {0, 4, 3, 2};

void setup() {
   println(maakMaxArray(lijst1, lijst2));
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-java">[0] 1
[1] 4
[2] 3
[3] 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-2---voorbereiding-v2"><a class="header" href="#les-2---voorbereiding-v2">Les 2 - Voorbereiding (V2)</a></h1>
<h1 id="theorie"><a class="header" href="#theorie">Theorie</a></h1>
<h2 id="screencast-onderwerp-1-het-geheugenmodel"><a class="header" href="#screencast-onderwerp-1-het-geheugenmodel">Screencast onderwerp 1 het geheugenmodel</a></h2>
<p><a href="http://www.youtube.com/playlist?list=PLpd9jJvk1PjmtR_LDjx6Ao8ddS5Q_-30a">http://www.youtube.com/playlist?list=PLpd9jJvk1PjmtR_LDjx6Ao8ddS5Q_-30a</a></p>
<h1 id="opgave-v21---geheugenmodel-volgorde"><a class="header" href="#opgave-v21---geheugenmodel-volgorde">Opgave V2.1 - Geheugenmodel volgorde</a></h1>
<p>Hieronder staan een aantal acties die in het geheugenmodel plaats kunnen vinden. Zet ze in de juiste volgorde.</p>
<p>a)   Lokale variabelen een waarde geven.</p>
<p>b)   Stack frame verwijderen.</p>
<p>c)   Returnwaarde kopiëren.</p>
<p>d)   Stack frame plaatsen.</p>
<p>e)   Globale variabelen plaatsen.</p>
<p>f)   Lokale variabelen plaatsen.</p>
<p><em>Tags: geheugenmodel, stack, stack frame, return</em></p>
<h1 id="opgave-v22---pijl-in-het-geheugenmodel"><a class="header" href="#opgave-v22---pijl-in-het-geheugenmodel">Opgave V2.2 - Pijl in het geheugenmodel</a></h1>
<h2 id="v22-a"><a class="header" href="#v22-a">V2.2 A</a></h2>
<p>Geef zo duidelijk mogelijk aan wat een pijl in het geheugenmodel precies betekent.</p>
<h2 id="v22-b"><a class="header" href="#v22-b">V2.2 B</a></h2>
<p>Geef aan waar deze pijl precies moet beginnen en waar deze pijl precies naar wijst.</p>
<p><em>Tags: geheugenmodel, variabele, array, referentie, geheugenadres</em></p>
<h1 id="opgave-v23---geheugenmodel-van-doekeertwee"><a class="header" href="#opgave-v23---geheugenmodel-van-doekeertwee">Opgave V2.3 - Geheugenmodel van doeKeerTwee</a></h1>
<h2 id="v23-a"><a class="header" href="#v23-a">V2.3 A</a></h2>
<p>In onderstaande code is de functie <code>doeKeerTwee</code> gegeven:</p>
<pre><code class="language-java">01 int testGetal = 5; 
02 
03 void setup() {
04    doeKeerTwee(testGetal); 
05    println(testGetal);
06 } 
07 
08 void doeKeerTwee(int getal) {
09    getal = 2 * getal; 
10 }
</code></pre>
<p>Teken het geheugenmodel op het moment dat <code>doeKeerTwee</code> op regel 4 is uitgevoerd, maar het stack frame van deze functie nog niet is verwijderd.</p>
<h2 id="v23-b"><a class="header" href="#v23-b">V2.3 B</a></h2>
<p>Hieronder staat de functie <code>doeKeerTwee</code></p>
<pre><code class="language-java">01 int[] testGetallen = {5, 5};
02
03 void setup() { 
04    doeKeerTwee(testGetallen);
05    println(testGetallen); 
06 }
07      
08 void doeKeerTwee(int[] getallen) {
09    for (int i = 0; i &lt; getallen.length; i++) { 
10       getallen[i] = 2 * getallen[i]; 
11    } 
12 } 
</code></pre>
<p>Teken het geheugenmodel op het moment dat <code>doeKeerTwee</code> op regel 4 is uitgevoerd, maar het stack frame van deze functie nog niet is verwijderd.</p>
<h2 id="v23-c"><a class="header" href="#v23-c">V2.3 C</a></h2>
<p>Vergelijk de geheugenmodellen uit Onderdeel A en Onderdeel B met elkaar en verklaar aan de hand van deze modellen waardoor de globale variabele <code>testGetal</code> niet van waarde is veranderd, maar de variabele <code>testGetallen</code> wel.</p>
<p><em>Tags: stap voor stap doorlopen, geheugenmodel, referentievariabele, primitieve variabele, lokale variabele, globale variabele.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-2---lesprogramma-l2"><a class="header" href="#les-2---lesprogramma-l2">Les 2 - Lesprogramma (L2)</a></h1>
<h1 id="opgave-l21---length"><a class="header" href="#opgave-l21---length">Opgave L2.1 - Length</a></h1>
<p><em>Klassikaal, begrip</em></p>
<p>Gegeven onderstaand programma</p>
<pre><code class="language-java">01 int[] lijst = {23, 30, 67};
02 void setup() {
03    for (int i = 0; i &lt; lijst.length; i++) {
04       println(lijst[i]);
05    }
06 }
</code></pre>
<p>Hieronder is het geheugenmodel te zien van het programma in de for-lus net na de aanroep van println op regel 5.</p>
<p><img src="images/geheugenmodelforlus.png" alt="geheugenmodel" /></p>
<h2 id="l21-a"><a class="header" href="#l21-a">L2.1 A</a></h2>
<p>Teken de variabele length met bijbehorende waarde op de juiste plek in dit model.</p>
<h2 id="l21-b"><a class="header" href="#l21-b">L2.1 B</a></h2>
<p>Vergelijk de .-operator (in <code>lijst.length</code>) met de []-operator (<code>lijst[i]</code>). Wat is de overeenkomst tussen beide operatoren?</p>
<p><em>Tags: geheugenmodel, eigenschap, operatoren</em></p>
<h1 id="opgave-l22---plakcodevoor"><a class="header" href="#opgave-l22---plakcodevoor">Opgave L2.2 - PlakCodeVoor</a></h1>
<p><em>Individueel en klassikaal, programmeerstijl, programmeervaardigheid</em></p>
<p>Gegeven onderstaande stuk code.</p>
<pre><code class="language-Java">String[] idLijst = {&quot;8b3&quot;, &quot;4bf&quot;, &quot;9h0&quot;};

void setup() {
   println(plakCodeVoorId(idLijst[0], &quot;NL&quot;));
}

String plakCodeVoorId(String id, String code) {
   return code + id;
}
</code></pre>
<p>In de variabele <code>idLijst</code> staan drie strings die gebruikt worden voor identificaties. In het hoofdprogramma wordt de code &quot;NL&quot; voor het eerste id geplakt uit <code>idLijst</code>. Hiervoor wordt de functie <code>plakCodeVoorId</code> gebruikt.</p>
<h2 id="l22-a"><a class="header" href="#l22-a">L2.2 A</a></h2>
<p>Ga ervan uit dat er een methode bestaat <code>plakCodeVoorIdLijst(String[] lijst, String code)</code> die de string in de variabele code voor elk element uit lijst plakt.
Schrijf een test in <code>setup</code> waarmee je deze methode zou kunnen testen. Zie opgave &quot;Zoeken in Array&quot; uit lesprogramma 1 voor de manier om een test op te zetten.</p>
<h2 id="l22-b"><a class="header" href="#l22-b">L2.2 B</a></h2>
<p>Implementeer de methode <code>plakCodeVoorIdLijst(String[] lijst, String code)</code> en zorg ervoor dat je de test uit opgave A slaagt.</p>
<h2 id="l22-c"><a class="header" href="#l22-c">L2.2 C</a></h2>
<p><em>Direct klassikaal, of eerst in tweetallen</em></p>
<p>Vergelijk jouw implementatie met die van anderen. Welke oplossing is het meest stijlvol en welke oplossing het minst?</p>
<h2 id="l22-d"><a class="header" href="#l22-d">L2.2 D</a></h2>
<p><em>Direct klassikaal, of eerst in tweetallen</em></p>
<p>Had de methode <code>plakCodeVoorIdLijst(String[] lijst, String code)</code> ook <code>plakCodeVoorId(String[] lijst, String code)</code> kunnen heten zonder een foutmelding te krijgen?</p>
<p><em>Tags: referentievariabele, array, overloading, new, return, geheugenmodel</em></p>
<h1 id="opgave-l23---notinitializedyet"><a class="header" href="#opgave-l23---notinitializedyet">Opgave L2.3 - NotInitializedYet</a></h1>
<p><em>Klassikaal, begrip</em></p>
<p>Voer onderstaand programma uit en je krijgt een foutmelding.</p>
<pre><code class="language-Java">void setup() {
   int[] deLijst;
   deLijst[0] = 1;
   
   println(deLijst);
}
</code></pre>
<p>Wat is de foutmelding?
Is dit een runtimefout, of een compile-time foutmelding.
Teken het geheugenmodel op het moment dat regel 3 wordt uitgevoerd en leg aan de hand van dit model uit welke vervelende situatie deze foutmelding heeft voorkomen.</p>
<p><em>Tags: compile-time foutmelding &lt;&gt; runtime foutmelding, new, initialiseren, referentievariabele</em></p>
<h1 id="opgave-l24---product"><a class="header" href="#opgave-l24---product">Opgave L2.4 - Product</a></h1>
<p><em>Klassikaal, nieuwe stof</em></p>
<p>Bekijk onderstaande code:</p>
<pre><code class="language-Java">void setup() {
   String product1naam = &quot;pc&quot;;
   String product2naam = &quot;mac&quot;;
   
   int product1prijs = 500;
   int product2prijs = 2000;
   
   println(product1naam + &quot; kost: &quot; + product1prijs + &quot; euro&quot;);
   println(product2naam + &quot; kost: &quot; + product2prijs + &quot; euro&quot;);
}
</code></pre>
<h2 id="l24-a"><a class="header" href="#l24-a">L2.4 A</a></h2>
<p>We willen graag gebruik maken van een loop om alle producten te printen. Pas de code zo aan dat dit mogelijk is.</p>
<h2 id="l24-b"><a class="header" href="#l24-b">L2.4 B</a></h2>
<p><em>Uitleg</em></p>
<p>Laten we naar één product kijken. We willen de eigenschappen naam en prijs groeperen. Dus we willen een 'ding' hebben met de eigenschappen naam en prijs:</p>
<pre><code class="language-Java">void setup() {
   ??Type?? product1;

   product1.naam = &quot;pc&quot;;
   product1.prijs = 500;

   println(product1.naam + &quot; kost: &quot; + product1.prijs + &quot; euro&quot;);
}
</code></pre>
<p>Vergelijk naam en prijs met de eigenschap <code>length</code> van array.
Het type van product1 moeten we zelf maken en dat doen we in een class (klasse). In deze klasse specificeren we ook alle eigenschappen en geven we een methode waarmee je een variabele van het gedefinieerde type kunt maken. Vergelijk dit met bijvoorbeeld <code>String[] lijst = new String[]()</code>. Ook voor onze zelf gedefinieerde type willen we iets dergelijks doen met het keyword <strong>new.</strong></p>
<h2 id="l24-c"><a class="header" href="#l24-c">L2.4 C</a></h2>
<p>Maak een tweede product object voor de MAC.
Moeten we ook een nieuwe klasse maken?</p>
<h1 id="extra-oefeningen-1"><a class="header" href="#extra-oefeningen-1">Extra Oefeningen</a></h1>
<h1 id="opgave-l25---geheugenmodel-van-doefunctie"><a class="header" href="#opgave-l25---geheugenmodel-van-doefunctie">Opgave L2.5 - Geheugenmodel van doeFunctie</a></h1>
<p>In opgave doeFunctie, onderdeel A uit de vorige les heb je een runtime administratie van alle variabelen gemaakt tijdens de uitvoer van het programma. Schrijf deze administratie om naar een geheugenmodel.</p>
<p><em>Tags: stap voor stap doorlopen, runtime administratie, geheugenmodel</em></p>
<h1 id="opgave-l26---samenvatting-geheugenmodel"><a class="header" href="#opgave-l26---samenvatting-geheugenmodel">Opgave L2.6 - Samenvatting geheugenmodel</a></h1>
<p>De opgaven gaan over de onderstaande code:</p>
<pre><code class="language-Java">01 int[] deLijst;
02 int hetGetal;
03 
04 void setup() {
05    hetGetal = 10;
06    deLijst = maakLijstMetEenGetal(2, hetGetal); 
07 }
08 
09 int[] maakLijstMetEenGetal(int lengte, int getal) {
10    int[] lijst = new int[lengte]; 
11    
12    for (int i = 0; i &lt; lijst.length; i++) {
13       lijst[i] = getal;
14    }
15 
16    return lijst;
17 }
</code></pre>
<h2 id="l26-a"><a class="header" href="#l26-a">L2.6 A</a></h2>
<p>Teken het geheugenmodel :</p>
<ul>
<li>na regel 2 en voor regel 4</li>
<li>na regel 5 en voor regel 6</li>
<li>tijdens de uitvoer van de methode op regel 6 en binnen deze methode na regel 9 en voor regel 10.</li>
<li>tijdens de uitvoer van de methode op regel 6 en binnen deze methode na regel 14 en voor regel 16.</li>
<li>na regel 6 en voor regel 7</li>
</ul>
<h2 id="l26-b"><a class="header" href="#l26-b">L2.6 B</a></h2>
<p>Hoe ziet de laatste versie van het geheugenmodel eruit als de declaratie van de variabelen <code>deLijst</code> en <code>hetGetal</code> in setup uitgevoerd wordt zoals hieronder te zien is:</p>
<pre><code class="language-Java">01 void setup() { 
02 int hetGetal = 10;
03 int[] deLijst = maakLijstMetEenGetal(2, hetGetal);
04 }
   // .. rest van de code weggelaten
</code></pre>
<h2 id="l26-c"><a class="header" href="#l26-c">L2.6 C</a></h2>
<p>Verklaar aan de hand van het geheugenmodel dat de methode setup niet bij de variabelen <code>lengte</code>, <code>getal</code> en <code>lijst</code> kan komen, maar de methode <code>maakLijstMetEenGetal</code> wel bij de variabele <code>deLijst</code> en <code>hetGetal</code>.
Gebruik in de uitleg zoveel mogelijk de technische begrippen die tot nu toe zijn behandeld.</p>
<h2 id="l26-d"><a class="header" href="#l26-d">L2.6 D</a></h2>
<p>Is het, over het algemeen, verstandig om de methode <code>maakLijstMetEenGetal</code> gebruik te laten maken van <code>deLijst</code> en <code>hetGetal</code>.
Gebruik in de uitleg zoveel mogelijk de technische begrippen die tot nu toe zijn behandeld.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-3---voorbereiding-v3"><a class="header" href="#les-3---voorbereiding-v3">Les 3 - Voorbereiding (V3)</a></h1>
<h1 id="theorie-1"><a class="header" href="#theorie-1">Theorie</a></h1>
<h2 id="screencast-onderwerp-2-klassen-en-objecten"><a class="header" href="#screencast-onderwerp-2-klassen-en-objecten">Screencast onderwerp 2 klassen en objecten</a></h2>
<h3 id="module-21"><a class="header" href="#module-21">Module 2.1</a></h3>
<p><a href="https://www.youtube.com/watch?v=1sAZozVIogQ&amp;list=PLpd9jJvk1PjmB_VNDp61-94kAbUHqcziD&amp;index=1">https://www.youtube.com/watch?v=1sAZozVIogQ&amp;list=PLpd9jJvk1PjmB_VNDp61-94kAbUHqcziD&amp;index=1</a></p>
<h3 id="module-22"><a class="header" href="#module-22">Module 2.2</a></h3>
<p><a href="https://www.youtube.com/watch?v=GXuor-sAxFQ&amp;list=PLpd9jJvk1PjmB_VNDp61-94kAbUHqcziD&amp;index=2">https://www.youtube.com/watch?v=GXuor-sAxFQ&amp;list=PLpd9jJvk1PjmB_VNDp61-94kAbUHqcziD&amp;index=2</a></p>
<p>NB: De sceencast van Module 2.3 moet worden bekeken in de voorbereiding van les 4</p>
<h2 id="boek"><a class="header" href="#boek">Boek</a></h2>
<h3 id="hoofdstuk-1"><a class="header" href="#hoofdstuk-1">Hoofdstuk 1</a></h3>
<p>1.1 en 1.2 pagina 32 en 33
1.4 t/m 1.7 (pagina 35 t/m 38 alleen de concepten bestuderen)</p>
<h3 id="hoofdstuk2"><a class="header" href="#hoofdstuk2">Hoofdstuk2</a></h3>
<p>2.3 t/m 2.4 (pagina 55 t/m 62, het sleutelwoord public kun je nu negeren)</p>
<h3 id="hoofdstuk-3"><a class="header" href="#hoofdstuk-3">Hoofdstuk 3</a></h3>
<p>3.12.2 (pagina 117 t/m 118)</p>
<h3 id="hoofdstuk-4"><a class="header" href="#hoofdstuk-4">Hoofdstuk 4</a></h3>
<p>4.14.2 (pagina 172 en 173)</p>
<h1 id="opgave-v31---product-met-constructor"><a class="header" href="#opgave-v31---product-met-constructor">Opgave V3.1 - Product met constructor</a></h1>
<p>Maak een constructor voor de klasse <code>Product</code> (uit lesprogramma 2) waarmee de <code>naam</code> en de <code>prijs</code> kunt initialiseren. Gebruik deze constructor om beide producten te initialiseren in de setup-functie van Processing.</p>
<h1 id="opgave-v32---damsteen-deel-1"><a class="header" href="#opgave-v32---damsteen-deel-1">Opgave V3.2 - Damsteen deel 1</a></h1>
<h2 id="v32-a"><a class="header" href="#v32-a">V3.2 A</a></h2>
<p>Maak de klasse waarmee je damstenen kunt maken en tekenen. Een damsteen is rond en moet een x- en y-punt hebben, een kleur en een diameter. Maak een constructor waarmee de gebruiker van de klasse alle eigenschappen van een damsteen kan meegeven.</p>
<h2 id="v32-b"><a class="header" href="#v32-b">V3.2 B</a></h2>
<p>Test de klasse <code>Damsteen</code> door in het hoofdprogramma twee damstenen te maken: een witte en een zwarte, en deze op het tekenvenster van Processing te tekenen.</p>
<h1 id="opgave-v33---student-null"><a class="header" href="#opgave-v33---student-null">Opgave V3.3 - Student null</a></h1>
<p>Gegeven onderstaande code:</p>
<pre><code class="language-java">01 void setup() {
02    Student s = new Student(&quot;kareltje&quot;, 12);
03    println(s.naam);
04 }
05
06 class Student {
07    String naam;
08    int nummer;
09    
10    Student(String naam, int nummer) {
09       naam = naam;
10       nummer = nummer;
11    }
12 }
</code></pre>
<p>Wanneer deze code uitgevoerd wordt, komt er in het uitvoervenster <code>null</code> te staan en geen &quot;kareltje&quot;. Teken het geheugenmodel op regel 3 (nog voordat het constructor stack frame is verwijderd van de stack), teken daarna het geheugenmodel op regel 12.
Verklaar aan de hand van deze schetsen, hoe het komt dat er <code>null</code> in het uitvoervenster komt te staan.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-3---lesprogramma-l3"><a class="header" href="#les-3---lesprogramma-l3">Les 3 - Lesprogramma (L3)</a></h1>
<h1 id="opgave-l31---damstenen-deel-2"><a class="header" href="#opgave-l31---damstenen-deel-2">Opgave L3.1 - Damstenen deel 2</a></h1>
<p><em>Individueel, programmeervaardigheid</em></p>
<h2 id="l31-a"><a class="header" href="#l31-a">L3.1 A</a></h2>
<p>Maak in het hoofdprogramma een array met vier damstenen: twee voor de witte speler en twee voor de zwarte speler. Initialiseer deze array en vul de array met vier nieuwe damsteenobjecten.</p>
<h2 id="l31-b"><a class="header" href="#l31-b">L3.1 B</a></h2>
<p>Pas de code in de draw-lus zo aan dat alle damstenen uit de array getekend worden.</p>
<p><em>Tags: array met objecten</em></p>
<h1 id="opgave-l32---persoonsverandering"><a class="header" href="#opgave-l32---persoonsverandering">Opgave L3.2 - Persoonsverandering</a></h1>
<p><em>Klassikaal, begrip</em></p>
<h2 id="l32-a"><a class="header" href="#l32-a">L3.2 A</a></h2>
<p>Gegeven onderstaande code:</p>
<pre><code class="language-java">01 class Persoon {
02    String naam;
03
04    Persoon(String naam) {
05       this.naam = naam;
06    }
07 }
08
09 void setup() {
10    Persoon p1 = new Persoon(&quot;han&quot;);
11    Persoon p2 = new Persoon(&quot;aim&quot;);
12
13    p1.naam = p2.naam;
14    p2.naam = &quot;kareltje&quot;;
15
16    println(p1.naam);
17 }
</code></pre>
<p>Teken het geheugenmodel op het moment dat <code>println(p1.naam)</code> op regel 16 wordt uitgevoerd en verklaar de uitvoer in de console (je hoeft het stack frame van <code>println</code> niet te tekenen).</p>
<h2 id="l32-b"><a class="header" href="#l32-b">L3.2 B</a></h2>
<p>Het programma wordt een beetje aangepast (zie regel 13) :</p>
<pre><code class="language-java">01 class Persoon {
02    String naam;
03    
04    Persoon(String naam) {
05       this.naam = naam;
06    }
07 }
08
09 void setup() {
10    Persoon p1 = new Persoon(&quot;han&quot;);
11    Persoon p2 = new Persoon(&quot;aim&quot;);
12 
13    p1 = p2;
14    p2.naam = &quot;kareltje&quot;;
15    
16    println(p1.naam);
17 }
</code></pre>
<p>Teken het geheugenmodel op het moment dat <code>println(p1.naam)</code> op regel 16 wordt uitgevoerd (zonder stack frame van <code>println</code>) en verklaar het verschil van de uitvoer in de console met onderdeel A.</p>
<p><em>Tags: geheugenmodel, primitieve types, referentietypes</em></p>
<h1 id="reflectieopgaven"><a class="header" href="#reflectieopgaven">Reflectieopgaven</a></h1>
<h1 id="opgave-l33---testen"><a class="header" href="#opgave-l33---testen">Opgave L3.3 - Testen</a></h1>
<p>Bij verschillende opgaven is er gevraagd om een test te schrijven voor een functie. Op welke plek, of plekken schrijf je in een processingprogramma die test?
Geef een schets van de code die je maakt, als je een test moet schrijven. Wanneer is de test van goede kwaliteit ?</p>
<h1 id="opgave-l34---foutmeldingen"><a class="header" href="#opgave-l34---foutmeldingen">Opgave L3.4 - Foutmeldingen</a></h1>
<p>Er zijn een aantal belangrijke foutmeldingen besproken. Welke foutmeldingen zijn dit? Waardoor wordt elke foutmelding veroorzaakt? Geef per foutmelding de oplossing.</p>
<h1 id="opgave-l35---programmeerstijl"><a class="header" href="#opgave-l35---programmeerstijl">Opgave L3.5 - Programmeerstijl</a></h1>
<p>Het hanteren van een goede programmeerstijl is een paar keer teruggekomen. Zoek de opgaven op waarin programmeerstijl aan de orde is geweest. Geef een paar vuistregels voor een goede programmeerstijl.</p>
<h1 id="opgave-l36---begrippen-verbinden"><a class="header" href="#opgave-l36---begrippen-verbinden">Opgave L3.6 - Begrippen verbinden</a></h1>
<p>Hieronder staan verschillende groepen met begrippen. Maak een zin waarin je elk begrip verbind door de constructie: &quot;bevat/kan bevatten&quot;, &quot;is/kan zijn&quot;, &quot;wordt weergegeven door/kan weergegeven worden door&quot;, &quot;zorgt voor/kan zorgen voor&quot;. Je mag de begrippen meervoud maken als dit de zin ten goede komt.</p>
<p>Bijvoorbeeld:
Rechthoek, Stack frame, Geheugenmodel</p>
<p>Levert
Het geheugenmodel kan stack frames bevatten die elk worden weergegeven door een rechthoek.</p>
<ul>
<li>Runtime administratie, geheugenmodel, variabelen.</li>
<li>Stack frame, geheugenmodel, functieaanroep.</li>
<li>Primitieve variabele, referentievariabele, object, array, integer</li>
<li>Geheugenadres, geheugenmodel, pijl.</li>
<li>Lokale variabele, parameter</li>
<li>Globale variabele declaratie, lokale variabele declaratie, functiedefinitie</li>
<li>Functiedefinitie, functieaanroep.</li>
</ul>
<h1 id="opgave-l37---opgaven-en-tags"><a class="header" href="#opgave-l37---opgaven-en-tags">Opgave L3.7 - Opgaven en tags</a></h1>
<h2 id="l37-a"><a class="header" href="#l37-a">L3.7 A</a></h2>
<p>Bekijk nogmaals elke opgave en bekijk welke opgaven je hebt gemaakt, welke opgaven je denkt te beheersen en van welke opgave je onderdelen nog niet begrijpt.</p>
<h2 id="l37-b"><a class="header" href="#l37-b">L3.7 B</a></h2>
<p>Bij elke opgave staan tags genoemd. Benoem de rol van elke tag in de opgave, of vraag dit na. Ga ook na of er een tag bij de opgave mist.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-4---voorbereiding-v4"><a class="header" href="#les-4---voorbereiding-v4">Les 4 - Voorbereiding (V4)</a></h1>
<h1 id="theorie-2"><a class="header" href="#theorie-2">Theorie</a></h1>
<h2 id="screencast-module-23-methoden"><a class="header" href="#screencast-module-23-methoden">Screencast module 2.3: Methoden</a></h2>
<h2 id="httpswwwyoutubecomwatchvg8xmstw4lt0listplpd9jjvk1pjmb_vndp61-94kabuhqczidindex3"><a class="header" href="#httpswwwyoutubecomwatchvg8xmstw4lt0listplpd9jjvk1pjmb_vndp61-94kabuhqczidindex3"><a href="https://www.youtube.com/watch?v=g8xMStW4lT0&amp;list=PLpd9jJvk1PjmB_VNDp61-94kAbUHqcziD&amp;index=3">https://www.youtube.com/watch?v=g8xMStW4lT0&amp;list=PLpd9jJvk1PjmB_VNDp61-94kAbUHqcziD&amp;index=3</a></a></h2>
<h2 id="boek-1"><a class="header" href="#boek-1">Boek</a></h2>
<h3 id="hoofdstuk2-1"><a class="header" href="#hoofdstuk2-1">Hoofdstuk2</a></h3>
<p>2.5 t/m 2.7 (pagina 63 t/m 67)</p>
<p>2.16 en 2.17 (pagina 80 t/m 84)</p>
<h1 id="opgave-v41---damsteen-deel-3"><a class="header" href="#opgave-v41---damsteen-deel-3">Opgave V4.1 - Damsteen deel 3</a></h1>
<h2 id="v41-a"><a class="header" href="#v41-a">V4.1 A</a></h2>
<p>In les 3 heb je een functie gemaakt voor het tekenen van een damsteen. Maak van deze een functie een methode in de klasse <code>Damsteen</code> waarin je alle code plaatst om één damsteen te tekenen.</p>
<h2 id="v41-b"><a class="header" href="#v41-b">V4.1 B</a></h2>
<p>Test de methode <code>tekenDamsteen</code> voor alle damstenen uit de array in de draw-lus van Processing.</p>
<h2 id="v41-c"><a class="header" href="#v41-c">V4.1 C</a></h2>
<p>Voeg de de klasse-variabele <code>isGeselecteerd</code> die de waarde <code>true</code>, of <code>false</code> kan hebben toe aan de klasse <code>Damsteen</code>. Zorg ervoor dat de methode <code>tekenDamsteen</code> een dikke rand (met de processing-methoden <code>stroke</code>, <code>strokeWeight</code> en <code>noStroke</code>) om de damsteen heen tekent als <code>isGeselecteerd</code> de waarde <code>true</code> heeft. Je hoeft niet zelf te detecteren of de damsteen geselecteerd is: het wordt gewoon een waarde die van buiten de klasse aan- of uitgezet kan worden.</p>
<h2 id="v41-d"><a class="header" href="#v41-d">V4.1 D</a></h2>
<p>Test de methode <code>tekenDamsteen</code>. Doe dit door in de setup van Processing de eigenschap <code>isGeselecteerd</code> van één van de damstenen op <code>true</code> te zetten. Zet dus in je code de boolean <code>isGeselecteerd</code> op <code>true</code>: je hoeft niet te detecteren of de muis in de buurt van de steen is of iets dergelijks.</p>
<h1 id="opgave-v42---slider-deel-1"><a class="header" href="#opgave-v42---slider-deel-1">Opgave V4.2 - Slider deel 1</a></h1>
<p>Plak onderstaande code in een nieuw venster van Processing.</p>
<pre><code class="language-java">float s1X, s1Y, s1Breedte, s1Hoogte;
int s1NPosities;
void setup() {
   size(300, 200);

   background(0);

   s1Breedte = 200;
   s1Hoogte = 50;
   s1X = (width - s1Breedte) / 2;
   s1Y = 50;
   s1NPosities = 5;
}
</code></pre>
<p>In deze opgave ga je deze code verplaatsen naar een klassendefinitie maken van een <code>Slider</code>.</p>
<h2 id="v42-a"><a class="header" href="#v42-a">V4.2 A</a></h2>
<p>De variabelen <code>s1X, s1Y, s1Breedte, s1Hoogte</code> en <code>s1NPosities</code> zijn eigenschappen van een slider. Maak een klasse <code>Slider</code> en plaats deze variabelen op de goede manier binnen deze klasse. Pas daarbij ook de namen op de goede manier aan.</p>
<h2 id="v42-b"><a class="header" href="#v42-b">V4.2 B</a></h2>
<p>De meeste code in de <code>setup</code> is eigenlijk initialisatiecode van de slider. Deze code kan beter in een constructor. Voeg een constructor toe aan de klasse <code>Slider</code> en test deze constructor in de <code>setup</code> van Processing</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-4---lesprogramma-l4"><a class="header" href="#les-4---lesprogramma-l4">Les 4 - Lesprogramma (L4)</a></h1>
<h1 id="opgave-l41---slider-deel-2"><a class="header" href="#opgave-l41---slider-deel-2">Opgave L4.1 - Slider deel 2</a></h1>
<p><em>Individueel, begrip</em></p>
<p>Hieronder is de draw lus van de slider gegeven. Verander de functies uit de oude code naar methoden van de klasse <code>Slider</code> en test de nieuwe klasse slider in de draw-lus van Processing.</p>
<pre><code class="language-java">void draw() {
   int s1HuidigePositie = bepaalSliderPositie(s1X, s1Breedte, s1NPosities);
   
   tekenSlider(s1X,s1Y, s1Breedte, s1Hoogte, s1HuidigePositie, s1NPosities);
}

void tekenSlider(float x, float y, float breedte, float hoogte, int positie, int nPosities) {
   float blokjeBreedte = breedte / nPosities;
   
   noStroke();
   
   fill(255);
   rect(x, y, breedte, hoogte);
   
   fill(#2257F0);
   rect(x + positie * blokjeBreedte, y, blokjeBreedte, hoogte);
}

int bepaalSliderPositie(float x, float breedte, int nPosities) {
   float blokjeBreedte = breedte / nPosities;
   if (mouseX &lt; x) {
      return 0;
   } else if (mouseX &gt;= breedte + x) {
      return nPosities - 1;
   } else {
      return floor((mouseX - x) / blokjeBreedte);
   }
}
</code></pre>
<p><em>Tags: methoden, functies, instantievariabelen, parameters, eigenschappen</em></p>
<h1 id="opgave-l42---tostring"><a class="header" href="#opgave-l42---tostring">Opgave L4.2 - toString()</a></h1>
<p><em>Klassikaal en individueel, string-representatie</em></p>
<h2 id="l42-a---persoon"><a class="header" href="#l42-a---persoon">L4.2 A - Persoon</a></h2>
<p><em>Klassikaal</em></p>
<p>Voeg aan de klasse <code>Persoon</code> uit opgave L3.2 B, twee extra attributen toe: <code>voornaam</code> en <code>tussenVoegsel</code>.</p>
<p>(Ga ervan uit dat naam de achternaam van een persoon bevat)</p>
<p>Voeg aan de klasse <code>Persoon</code> de methode <code>toString()</code> die een relevante string retourneert. Let op dat bij een persoon zonder tussenvoegsel geen 2 spaties komen te staan tussen voor- en achternaam. Test de methode in het hoofdprogramma.</p>
<h2 id="l42-b---damsteen"><a class="header" href="#l42-b---damsteen">L4.2 B - Damsteen</a></h2>
<p><em>Individueel</em></p>
<p>Voeg aan de klasse <code>Damsteen</code> de methode <code>toString()</code> die een relevante string retourneert. Test de methode in het hoofdprogramma.</p>
<p><em>Tags: toString</em></p>
<h1 id="opgave-l43---kaartautomaat"><a class="header" href="#opgave-l43---kaartautomaat">Opgave L4.3 - Kaartautomaat</a></h1>
<p><em>Tweetallen, programmeervaardigheid</em></p>
<p>De klasse <code>KaartjesAutomaat</code> simuleert een kaartautomaat bij een bioscoop die kaartjes kan leveren voor één film met één prijs. De film en de prijs van een kaartje wordt ingesteld via de constructor. Instanties zorgen ervoor dat een gebruiker alleen bedragen inwerpen die groter zijn dan 0 en dat de automaat alleen een kaartje afdrukt als er voldoende geld 'ingeworpen' is. Daarnaast kan het wisselgeld bepaald en teruggegeven worden. Ook wordt het totaal ingeworpen bedrag bijgehouden en kan de automaat geleegd worden (waardoor het totaal weer op 0 komt te staan). De afdruk van de kaartjes wordt gesimuleerd door de naam van het kaartje en de prijs naar de console te schrijven (eventueel samen met artistieke asciiart).</p>
<h2 id="l43-a---maak-het-klassenontwerp"><a class="header" href="#l43-a---maak-het-klassenontwerp">L4.3 A - Maak het klassenontwerp</a></h2>
<p>Teken het klassendiagram met de naam van de klasse, de klassevariabelen (a.k.a. eigenschappen of attributen) (inclusief type) en de methoden (inclusief parameters met type en returntype). Maak voor deze opgave gebruik van je kennis over Business Class Diagram uit FAT. Het klassendiagram zelf komt uitgebreider aan bod in de screencasts van les 5 en in les 8 worden uitgebreidere klassendiagrammen behandeld.</p>
<h2 id="l43-b---implementeren-en-testen"><a class="header" href="#l43-b---implementeren-en-testen">L4.3 B - Implementeren en testen</a></h2>
<h4 id="implementatieteam"><a class="header" href="#implementatieteam">Implementatieteam</a></h4>
<p>Maak deze klasse en zorg ervoor dat de code zo goed mogelijk omgaat met foutieve invoer.</p>
<h4 id="testteam"><a class="header" href="#testteam">Testteam</a></h4>
<p>Maak het hoofdprogramma waarin je één instantie van deze klasse test. Test door alle uitvoer met <code>println</code> naar het uitvoerscherm te schrijven. Verzin invoer en bedenk welke uitvoer je wilt hebben. Probeer zo grondig mogelijk te testen door naast geldige invoer ook foutieve invoer aan de ticketmachine te voeren.</p>
<h1 id="opgave-l44---wat-is-een-string--hoe-verhoudt-zich-dat-tot-objecten"><a class="header" href="#opgave-l44---wat-is-een-string--hoe-verhoudt-zich-dat-tot-objecten">Opgave L4.4 - Wat is een String (&amp; hoe verhoudt zich dat tot objecten?)</a></h1>
<p><em>Klassikaal</em></p>
<p>Voer onderstaande code uit en bekijk de uitvoer in de console.</p>
<pre><code class="language-java">class Persoon {
   String naam;

   Persoon(String naam) {
      this.naam = naam;
   }
}

void setup() {
   String persoon1 = &quot;Hans&quot;;
   String persoon2 = &quot;Hans&quot;;

   if (persoon1 == persoon2){
      println(&quot;dezelfde persoon&quot;);
   } else {
      println(&quot;ander persoon&quot;);
   }

   String persoon3 = new String(&quot;Grietje&quot;);
   String persoon4 = new String(&quot;Grietje&quot;);

   if (persoon3 == persoon4){
      println(&quot;dezelfde persoon&quot;);
   } else {
      println(&quot;ander persoon&quot;);
   }

   Persoon persoon5 = new Persoon(&quot;Rapunzel&quot;);
   Persoon persoon6 = new Persoon(&quot;Rapunzel&quot;);

   if (persoon5 == persoon6){
      println(&quot;dezelfde persoon&quot;);
   } else {
      println(&quot;ander persoon&quot;);
   }
}
</code></pre>
<h2 id="l44-a"><a class="header" href="#l44-a">L4.4 A</a></h2>
<p>Is een <code>String</code> op basis van de uitvoer een referentietype, of een primitief type?</p>
<h2 id="l44-b"><a class="header" href="#l44-b">L4.4 B</a></h2>
<p>Teken het geheugenmodel op het moment dat de methode <code>setup()</code> uitgevoerd is, maar nog niet van de Heap verwijderd is.</p>
<h2 id="l44-c"><a class="header" href="#l44-c">L4.4 C</a></h2>
<p><em>Klassikaal, discussie</em></p>
<p>Net als de <code>toString()</code> methode, hebben alle objecten ook de beschikking over de <code>equals()</code> methode. Verander in voorgaande code de vergelijking '==' in als volgt:
<code>persoon1.equals(persoon2)</code></p>
<p>Doe dit voor alle 3 vergelijkingen.
Wat valt hier op?</p>
<h1 id="extra-oefeningen-2"><a class="header" href="#extra-oefeningen-2">Extra oefeningen</a></h1>
<h1 id="opgave-l45---meer-klassendefinities"><a class="header" href="#opgave-l45---meer-klassendefinities">Opgave L4.5 - Meer klassendefinities</a></h1>
<h2 id="l45-a---student"><a class="header" href="#l45-a---student">L4.5 A - Student</a></h2>
<p>Maak de klasse <code>Student</code>. Een student heeft een <code>naam</code> (voornaam en achternaam) en een <code>nummer</code>. Maak een bijpassende constructor en test de klasse in het hoofdprogramma</p>
<h2 id="l45-b---dobbelsteen"><a class="header" href="#l45-b---dobbelsteen">L4.5 B - Dobbelsteen</a></h2>
<p>Maak de klasse <code>Dobbelsteen</code>. Verzin zelf welke eigenschap(pen) een dobbelsteen moet hebben. Maak een bijpassende constructor en test de klasse in het hoofdprogramma.</p>
<h1 id="opgave-l46--slider-tostring"><a class="header" href="#opgave-l46--slider-tostring">Opgave L4.6- Slider toString()</a></h1>
<p>Voeg aan de klasse <code>Slider</code> de methode <code>toString()</code> die een relevante string retourneert. Test de methoden in het hoofdprogramma.</p>
<h1 id="opgave-l47---bestaande-constructor-gebruiken"><a class="header" href="#opgave-l47---bestaande-constructor-gebruiken">Opgave L4.7 - Bestaande constructor gebruiken</a></h1>
<p>Maak een tweede constructor voor <code>Klok</code> waarmee je ook de tijd kunt initialiseren. Voorkom herhalende code door in de nieuwe constructor gebruik te maken van de constructor die al bestaat en de methode <code>setTijd()</code>.
Hieronder is alvast de definitie:</p>
<pre><code class="language-java">Klok(float x, float y, float breedte, int uren, int minuten) {
   //TODO
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-5---voorbereiding-v5"><a class="header" href="#les-5---voorbereiding-v5">Les 5 - Voorbereiding (V5)</a></h1>
<h1 id="theorie-3"><a class="header" href="#theorie-3">Theorie</a></h1>
<h2 id="screencast-onderwerp-3-interactie-tussen-objecten"><a class="header" href="#screencast-onderwerp-3-interactie-tussen-objecten">Screencast onderwerp 3 interactie tussen objecten</a></h2>
<p><a href="http://www.youtube.com/playlist?list=PLpd9jJvk1Pjlt8c30X9uu7N9r2aQVey93">http://www.youtube.com/playlist?list=PLpd9jJvk1Pjlt8c30X9uu7N9r2aQVey93</a></p>
<h2 id="boek-2"><a class="header" href="#boek-2">Boek</a></h2>
<h3 id="hoofdstuk-3-1"><a class="header" href="#hoofdstuk-3-1">Hoofdstuk 3</a></h3>
<p>3.1 t/m 3.11 (pagina 98 t/m 115)</p>
<p>3.16 (pagina 128 t/m 131)</p>
<h1 id="opgave-v51---dambord-met-stenen"><a class="header" href="#opgave-v51---dambord-met-stenen">Opgave V5.1 - Dambord met stenen</a></h1>
<h2 id="v51-a"><a class="header" href="#v51-a">V5.1 A</a></h2>
<p>Maak een dambord volgens onderstaande specificatie.</p>
<h3 id="instantievariabele"><a class="header" href="#instantievariabele">Instantievariabele</a></h3>
<p>Een dambord bevat een Array genaamd <code>stenen</code> waarin vier damstenen zitten. Twee van deze stenen zijn zwart, twee wit. De positie en de diameter van de damstenen maakt niet uit als de diameter van elke steen maar gelijk is.</p>
<h3 id="methode"><a class="header" href="#methode">Methode</a></h3>
<p>Een dambord heeft één methode: <code>tekenDamstenen()</code> die alle damstenen die in de variabele stenen zit tekent.</p>
<p>Je kunt onderstaand klassendiagram gebruiken.</p>
<p><img src="images/damstenenCD.png" alt="damstenenCD" /></p>
<h2 id="v51-b"><a class="header" href="#v51-b">V5.1 B</a></h2>
<p>Test de klasse <code>Dambord</code> met bijbehorende methode <code>tekenDamstenen</code> in het hoofdprogramma.</p>
<h1 id="opgave-v52---student-op-school"><a class="header" href="#opgave-v52---student-op-school">Opgave V5.2 - Student op School</a></h1>
<p>Gegeven onderstaande klassendiagram.</p>
<p><img src="images/studentopschool.png" alt="studentopschool" /></p>
<p>Met bijbehorende code:</p>
<h2 id="klasse-school"><a class="header" href="#klasse-school">Klasse School</a></h2>
<pre><code class="language-java">01 class School {
02    String naam;
03    
04    School(String naam) {
05       this.naam = naam;
06    }
07 }
</code></pre>
<h2 id="klasse-student"><a class="header" href="#klasse-student">Klasse Student</a></h2>
<pre><code class="language-java">01 class Student {
02    String naam;
03    int nummer;
04    School school;
05 
06    Student(String naam, int nummer, String school) {
07       this.naam = naam;
08       this.nummer = nummer;
09       this.school = new School(school);
10    }
11 }
</code></pre>
<h2 id="hoofdprogramma"><a class="header" href="#hoofdprogramma">Hoofdprogramma</a></h2>
<pre><code class="language-java">01 void setup() {
02    School deSchool = new School(&quot;AIM&quot;);
03
04    Student s1 = new Student(&quot;hanneke&quot;, 1, &quot;AIM&quot;);
05    Student s2 = new Student(&quot;femke&quot;, 2, &quot;AIM&quot;);
06 }
</code></pre>
<p>De constructor van de klasse <code>Student</code> bevat een fout die vaak voorkomt en makkelijk verborgen blijft. Het datatype van de parameter <code>school</code> is onhandig, waardoor in regel 9 de fout ontstaat.</p>
<h2 id="v52-a"><a class="header" href="#v52-a">V5.2 A</a></h2>
<p>Teken het geheugenmodel van het hoofdprogramma op het moment dat deze regel 5 net heeft uitgevoerd.</p>
<h2 id="v52-b"><a class="header" href="#v52-b">V5.2 B</a></h2>
<p>Leg op basis van deze schets uit wat er fout gaat.</p>
<h2 id="v52-c"><a class="header" href="#v52-c">V5.2 C</a></h2>
<p>Lost onderstaande verbetering op regel 4 en 5 aan het hoofdprogramma de fout op?</p>
<pre><code class="language-java">01 void setup() {
02    School deSchool = new School(&quot;AIM&quot;);
03
04    Student s1 = new Student(&quot;hanneke&quot;, 1, deSchool.naam);
05    Student s2 = new Student(&quot;femke&quot;, 2, deSchool.naam);
06 }   
</code></pre>
<p><em>Tags: referentievariabele, verschillende &lt;&gt; dezelfde instantie</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-5---lesprogramma-l5"><a class="header" href="#les-5---lesprogramma-l5">Les 5 - Lesprogramma (L5)</a></h1>
<h1 id="opgave-l51---geheelgetal"><a class="header" href="#opgave-l51---geheelgetal">Opgave L5.1 - Geheelgetal</a></h1>
<p><em>Individueel, begrip</em></p>
<p>In onderstaand programma is er een klasse gemaakt voor een geheel getal. De klasse heeft één eigenschap met de waarde van het getal. Hoewel het misschien raar is om een klasse te maken voor een ding dat al bestaat, gaat het in deze opgave om het verschil tussen een klasse en primitieve te onderzoeken.</p>
<pre><code class="language-java">01 class GeheelGetal {
02    int waarde;
03    
04	  GeheelGetal(int startwaarde) {
05       waarde = startwaarde;
06    }
07 }
08
09 void setup() {
10    int getal1 = 10;
11    GeheelGetal getal2 = new GeheelGetal(10);
12
13    println(&quot;getal1: &quot; + getal1);
14    println(&quot;getal2: &quot; + getal2.waarde);
15    println(&quot;-------------------------&quot;);
16
17    telErTienBijOp(getal1);
18    telErTienBijOp(getal2);
19
20    println(&quot;getal1: &quot; + getal1);
21    println(&quot;getal2: &quot; + getal2.waarde);
22 }
23 
24 void telErTienBijOp(int getal) {
25    getal += 10;
26 }
27
28 void telErTienBijOp(GeheelGetal getal) {
29    getal.waarde += 10;
30 }
</code></pre>
<p>Draai het programma in Processing en bekijk de uitvoer: regels 20 en 21 leveren niet hetzelfde getal.</p>
<h2 id="l51-a"><a class="header" href="#l51-a">L5.1 A</a></h2>
<p>Teken het geheugenmodel op het moment dat <code>telErTienBijOp(getal1)</code> op regel 17 bezig is en hierbinnen bij regel 26 is.</p>
<h2 id="l51-b"><a class="header" href="#l51-b">L5.1 B</a></h2>
<p>Teken het geheugenmodel op het moment dat <code>telErTienBijOp(getal2)</code> op regel 18 bezig is en hierbinnen bij regel 30 is.</p>
<h2 id="l51-c"><a class="header" href="#l51-c">L5.1 C</a></h2>
<p>Verklaar op basis van de twee geheugenmodellen het verschil in de uitvoer.</p>
<h2 id="l51-d"><a class="header" href="#l51-d">L5.1 D</a></h2>
<p><em>Klassikaal</em></p>
<p>Op regels 14 en 21 kun je niet <code>println(getal2)</code> typen, maar moet je <code>println(getal2.waarde)</code> gebruiken. Met een kleine toevoeging aan de klasse GeheelGetal is dit wel mogelijk. Welke? Waarom zouden we dit willen?</p>
<p><em>Tags: Geheugenmodel, overloading, primitieve typen, referentietypen, pass by reference, toString</em></p>
<h1 id="opgave-l52---kaartjesautomaat-2-meerdere-soorten-kaartjes"><a class="header" href="#opgave-l52---kaartjesautomaat-2-meerdere-soorten-kaartjes">Opgave L5.2 - KaartjesAutomaat 2: Meerdere soorten kaartjes</a></h1>
<p><em>Tweetallen, programmeervaardigheid</em></p>
<h2 id="functionele-informatie"><a class="header" href="#functionele-informatie">Functionele informatie</a></h2>
<p>De klasse <code>KaartjesAutomaat</code> moet nu kaartjes kunnen bijhouden van verschillende soorten films. De gebruiker van de automaat kan dan één kaartje selecteren uit het aanbod van de automaat. Natuurlijk moet het gekozen kaartje ook weer ontkozen kunnen worden. De overige functionaliteit is hetzelfde.</p>
<h2 id="technische-informatie"><a class="header" href="#technische-informatie">Technische informatie</a></h2>
<p>Alle informatie en al het gedrag van een kaartje moet uit de klasse <code>KaartjesAutomaat</code> gehaald worden en in een nieuwe klasse met de naam <code>Kaartje</code> worden gestopt. De klasse <code>KaartjesAutomaat</code> moet een array van <code>Kaartje</code> bijhouden. Daarnaast moet er in een instantievariabele bijgehouden worden welk kaartje is geselecteerd. Het selecteren van het kaartje gaat doormiddel van de index in de array van kaartsoorten (dus niet gaan zoeken op kaartnaam o.i.d.). De lijst met kaartsoorten moet in de constructor van <code>KaartjesAutomaat</code> meegegeven worden en kan daarna niet worden gewijzigd.</p>
<h2 id="l52-a---ontwerpen-van-de-klassen"><a class="header" href="#l52-a---ontwerpen-van-de-klassen">L5.2 A - Ontwerpen van de klassen</a></h2>
<p>Teken het klassendiagram met de namen van de klassen, de klassenvariabelen (inclusief type) en de methoden (inclusief parameters met type en returntype).</p>
<p>Teken het geheugenmodel voor een <code>KaartjesAutomaat</code> met 3 kaartsoorten. Ga ervan uit dat de constructor van de <code>KaartjesAutomaat</code> net is uitgevoerd.</p>
<h2 id="l52-b---ontwerpen-van-de-testen"><a class="header" href="#l52-b---ontwerpen-van-de-testen">L5.2 B - Ontwerpen van de testen</a></h2>
<p>Ontwerp* een programma waarmee je elke methode van de nieuwe klassen kunt testen. Let op dat je per methode bedenkt of er Randvoorwaarden** zijn om de methode met succes te kunnen uitvoeren. Bedenk welke foutmelding er geprint moet worden als er niet aan de randvoorwaarde is voldaan.</p>
<p>Schrijf de testen die je ontworpen uit in een processing programma.</p>
<h4 id="ontwerp"><a class="header" href="#ontwerp">*Ontwerp</a></h4>
<p>In dit geval wordt met ontwerp bedoeld dat je een programma maakt waarin je elke methode van de <code>KaartjesAutomaat</code> en <code>Kaartje</code> test. Je moet dus verzinnen in welke volgorde je deze methodes aanroept en hoe vaak je dit doet en wat je met die volgorde wilt bereiken.</p>
<h4 id="randvoorwaarden"><a class="header" href="#randvoorwaarden">**Randvoorwaarden</a></h4>
<p>Een randvoorwaarde van de methode <code>printKaartje</code> bijvoorbeeld is dat het saldo groter of gelijk aan de prijs van het kaartje dat geprint moet worden. Als er niet aan deze randvoorwaarde is voldaan, kan deze methode de taak waar hij voor bedoeld is niet uitvoeren (en daar moet je als programmeur iets mee doen).</p>
<h2 id="l53-c---testen-en-implementeren"><a class="header" href="#l53-c---testen-en-implementeren">L5.3 C - Testen en implementeren</a></h2>
<p>Los vervolgens error voor error op, door de klasse <code>Kaartje</code> te maken en de klasse <code>KaartjesAutomaat</code> aan te passen.</p>
<h1 id="uitdaging"><a class="header" href="#uitdaging">Uitdaging</a></h1>
<h1 id="opgave-l53---kaartjesautomaat-3"><a class="header" href="#opgave-l53---kaartjesautomaat-3">Opgave L5.3 - KaartjesAutomaat 3</a></h1>
<h2 id="functionele-informatie-1"><a class="header" href="#functionele-informatie-1">Functionele informatie</a></h2>
<p>De <code>KaartjesAutomaat</code> wordt verder aangepast. Er kunnen meerdere kaartjes tegelijkertijd worden gekocht (in één bestelling). Dit kunnen verschillende soorten kaartjes zijn, maar ook dezelfde.</p>
<h2 id="technische-informatie-1"><a class="header" href="#technische-informatie-1">Technische informatie</a></h2>
<p>De kaartjes die de gebruiker gaat kopen, moeten in een nieuwe klasse met de naam <code>Bestelling</code> komen. Bedenk zelf hoe de bestelling de gekozen kaartjes en de hoeveelheid kaartjes van één soort gaat bijhouden. Bedenk ook zelf welke methode in welke klasse ervoor zorgt dat er meerdere kaartjes van één kaartsoort geselecteerd kunnen worden.</p>
<h2 id="l53-a---ontwerpen-van-de-klassen"><a class="header" href="#l53-a---ontwerpen-van-de-klassen">L5.3 A - Ontwerpen van de klassen</a></h2>
<p>Teken het klassendiagram met de namen van de klassen, de eigenschappen van de velden (inclusief type) en de methoden (inclusief parameters met type en returntype).</p>
<p>Teken het geheugenmodel voor een <code>KaartjesAutomaat</code> met 3 kaarsoorten in één <code>Bestelling</code>.</p>
<h2 id="l53-b---ontwerpen-van-de-testen"><a class="header" href="#l53-b---ontwerpen-van-de-testen">L5.3 B - Ontwerpen van de testen</a></h2>
<p>Ontwerp een programma waarmee je elke methode van de nieuwe klassen kunt testen. Let op dat je per methode bedenkt of er randvoorwaarden zijn om de methode met succes te kunnen uitvoeren. Print een foutmelding als er niet aan de randvoorwaarde is voldaan.</p>
<p>Schrijf de testen die je ontworpen hebt in opgave B uit in een processingprogramma.</p>
<h2 id="l53-c---testen-en-implementeren-1"><a class="header" href="#l53-c---testen-en-implementeren-1">L5.3 C - Testen en implementeren</a></h2>
<p>Los vervolgens error voor error op, door de nieuwe klasse te maken en de bestaande klassen aan te passen waar nodig.</p>
<h1 id="extra-oefeningen-3"><a class="header" href="#extra-oefeningen-3">Extra oefeningen</a></h1>
<h1 id="opgave-l54---verhouding-breedtehoogte-in-teller"><a class="header" href="#opgave-l54---verhouding-breedtehoogte-in-teller">Opgave L5.4 - Verhouding breedte/hoogte in Teller</a></h1>
<p>Ga bij deze opgave uit van de onderstaande code uit een eerdere screencast</p>
<pre><code class="language-java">Klok klok;

void setup(){
   size(400,300);
   background(255);

   klok = new Klok(150, 100, 100);
   
   klok.setTijd(22, 58);
   klok.tik();
   klok.tik();
   klok.tekenKlok();
}

void draw(){
   klok.tik();
   klok.tekenKlok();
}

class Klok{
   Teller minutenTeller;
   Teller urenTeller;
   float x, y, hoogte, breedte;

   Klok(float x, float y, float breedte){
      this.x = x;
      this.y = y;
      this.breedte = breedte;
      this.hoogte = breedte * 0.4f;
      urenTeller = new Teller(24, x, y, breedte / 2, hoogte);
      minutenTeller = new Teller(60, x + breedte / 2, y, breedte / 2, hoogte);
   }

   void setTijd(int uren, int minuten){
      minutenTeller.waarde = minuten;
      urenTeller.waarde = uren;
   }

   void tik(){
      minutenTeller.tik();
      if (minutenTeller.waarde == 0){
         urenTeller.tik();
      }
   }

   void tekenKlok(){
      urenTeller.tekenTeller();
      minutenTeller.tekenTeller();
   }
}

class Teller{
   int maximum;
   int waarde;
   float x, y, hoogte, breedte;

   Teller(int maximum, float x, float y, float breedte, float hoogte){
      this.maximum = maximum;
      waarde = 0;
      this.x = x;
      this.y = y;
      this.breedte = breedte;
      this.hoogte = hoogte;
    }

   void tik(){
      waarde = (waarde + 1) % maximum;
   }

   void tekenTeller(){
      rectMode(CENTER);
      noStroke();
      fill(0);
      rect(x, y, breedte, hoogte);
      fill(255, 0 , 0);
      textSize(hoogte);
	  textAlign(CENTER);
	  float verschuiving = (textAscent() - textDescent())/2;
	  text(geefTijdNotatie(), x, y + verschuiving);
   }

   String geefTijdNotatie(){
      if (waarde &lt; 10){
         return &quot;0&quot; + str(waarde);
      } else {
         return str(waarde);
      }
   }
}
</code></pre>
<p>(De code staat ook op Onderwijs Online bij Les 5: <em>KlokApp.zip</em>)</p>
<h2 id="l54-a"><a class="header" href="#l54-a">L5.4 A</a></h2>
<p>De verhouding tussen de breedte en de hoogte wordt nu afgevangen in <code>Klok</code> door het statement</p>
<p><code>hoogte = breedte * 0.4f;</code></p>
<p>Zorg ervoor dat de juiste verhouding tussen de breedte en de hoogte in de klasse <code>Teller</code> wordt afgevangen in plaats van in de klasse <code>Klok</code>. Test de wijzigingen goed.</p>
<h2 id="l54-b"><a class="header" href="#l54-b">L5.4 B</a></h2>
<p>Welke implementatie geniet volgens jou de voorkeur:</p>
<p>A.  Verhouding tussen de hoogte en de breedte in <code>Klok</code></p>
<p>B.  Verhouding tussen de hoogte en breedte in <code>Teller</code></p>
<p>C.  Maakt niet uit</p>
<p>Probeer zo goed mogelijk te formuleren waarom je voor jouw keuze hebt gekozen. Als je geen reden kunt verzinnen, mag je ook aangeven dat het om een vaag gevoel, of intuïtie gaat. Probeer dan dit zo helder mogelijk te beschrijven.</p>
<h1 id="opgave-l55----tostring-in-klok"><a class="header" href="#opgave-l55----tostring-in-klok">Opgave L5.5 -- toString() in Klok</a></h1>
<h2 id="l55-a"><a class="header" href="#l55-a">L5.5 A</a></h2>
<p>Welke informatie zou je in de string representatie van <code>Klok</code> willen stoppen?</p>
<h2 id="l55-b---uitdaging"><a class="header" href="#l55-b---uitdaging">L5.5 B - Uitdaging</a></h2>
<p>Implementeer de <code>toString</code> in <code>Klok</code> op basis van het antwoord op opgave A.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-6---voorbereiding-v6"><a class="header" href="#les-6---voorbereiding-v6">Les 6 - Voorbereiding (V6)</a></h1>
<h1 id="theorie-4"><a class="header" href="#theorie-4">Theorie</a></h1>
<h2 id="screencast-onderwerp-41-van-processing-naar-java"><a class="header" href="#screencast-onderwerp-41-van-processing-naar-java">Screencast onderwerp 4.1 van Processing naar Java</a></h2>
<p><a href="https://www.youtube.com/watch?v=Y2w9OvLTg8A&amp;list=PLpd9jJvk1PjnMmrtlNeOzviLhJolx0_oi&amp;index=1">https://www.youtube.com/watch?v=Y2w9OvLTg8A&amp;list=PLpd9jJvk1PjnMmrtlNeOzviLhJolx0_oi&amp;index=1</a></p>
<p>NB: Onderwerp 4.2 t/m 4.4 komen in les 7 aan bod</p>
<h1 id="opgave-v61---installeren-van-ide-eclipse-of-intellij"><a class="header" href="#opgave-v61---installeren-van-ide-eclipse-of-intellij">Opgave V6.1 - Installeren van IDE, Eclipse of IntelliJ</a></h1>
<p>Vanaf de komende les gaan we gebruik maken van een geavanceerdere programmeeromgeving: IntelliJ of Eclipse. Download en installeer ter voorbereiding van deze les je IDE van voorkeur.</p>
<h3 id="intellij"><a class="header" href="#intellij">IntelliJ</a></h3>
<p>De IntelliJ IDEA is er in 2 versies. De gratis Community en de betaalde Ultimate editie.</p>
<blockquote>
<p>Hoewel de Community editie voor dit vak voldoende is, raad ik je toch aan om de Ultimate editie te gaan gebruiken. De Ultimate editie ondersteund n.l. meer frameworks die je wellicht in de hoofdfase gaat gebruiken.
Voor studenten is de Ultimate editie gratis gedurende hun studie. Hiervoor moet je wel een JetBrains account aanmaken. </p>
</blockquote>
<ol>
<li>Ga naar <a href="https://www.jetbrains.com/community/education/#students">Free Educational Licenses - Community Support (jetbrains.com)</a> en vraag een licentie aan.</li>
<li>Volg de instructies in de mail die je vervolgens toegestuurd krijgt.</li>
<li>Na installatie en starten van IntelliJ, kom je in het opstart scherm. Kies hier voor een nieuw project, en kies de directory waar je je project wilt bewaren. Kies als taal natuurlijk Java en kies voor het buildsysteem IntelliJ. Kies bij JDK voor versie 17 (16 mag ook). Hoewel JDK 18 ook al beschikbaar is, is toch het advies om hier niet voor te kiezen. Het is op dit moment nog niet bekend of de Processing library en de Yaeger game engine al lekker samenwerken met JDK 18. Mocht de juiste JDK niet in het dropdown lijstje voorkomen, dan is er de optie in de dropdown om een JDK te downloaden.</li>
</ol>
<h3 id="eclipse"><a class="header" href="#eclipse">Eclipse</a></h3>
<ol>
<li>Ga naar <a href="http://www.eclipse.org/downloads">www.eclipse.org/downloads</a></li>
<li>Download de Eclipse Installer: eclipse-inst-jre-win64 (of eclipse-inst-jre-mac64 voor de Mac)</li>
<li>Run de installer.</li>
<li>Kies voor de Eclipse-versie &quot;Eclipse IDE for Java Developers&quot;</li>
<li>Laat de default waarden staan en klik &quot;INSTALL&quot;</li>
<li>Na installatie kun je Eclipse meteen vanuit de installer starten. (Als het goed is staat er ook een icoon op je bureaublad)</li>
<li>Kies voor de standaard workspace.</li>
</ol>
<h1 id="opgave-v62---student-in-java"><a class="header" href="#opgave-v62---student-in-java">Opgave V6.2 - Student in Java</a></h1>
<p>Zorg ervoor dat de <code>Student</code> en de <code>School</code> uit de opgave V5.2 - StudentOpSchool (uit les 5 -- Voorbereiding) in Java draait.</p>
<h1 id="pen-en-papier-meenemen"><a class="header" href="#pen-en-papier-meenemen">Pen en papier meenemen</a></h1>
<p>In de les gaan we de oefentoets maken en bespreken. Neem dus pen en papier mee.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-6---lesprogramma-l6"><a class="header" href="#les-6---lesprogramma-l6">Les 6 - Lesprogramma (L6)</a></h1>
<p>Op Onderwijs Online staan enkele extra oefeningen voor het geheugenmodel (Zie: 2.4 Geheugenmodel: reader en extra oefeningen)</p>
<h1 id="opgave-l61---voorbeeldtentamen"><a class="header" href="#opgave-l61---voorbeeldtentamen">Opgave L6.1 - Voorbeeldtentamen</a></h1>
<p>Voorbeeldtentamen op papier.</p>
<h1 id="opgave-l62---geheugenmodel-van-tekendamsteen"><a class="header" href="#opgave-l62---geheugenmodel-van-tekendamsteen">Opgave L6.2 - Geheugenmodel van tekenDamsteen</a></h1>
<h2 id="l62-a"><a class="header" href="#l62-a">L6.2 A</a></h2>
<p>Gegeven onderstaande code om een damsteen te maken.</p>
<pre><code class="language-java">class Damsteen {
   float x, y, d;
   int kleur;
   boolean isGeselecteerd;

   Damsteen(float x, float y, float d, int kleur) {
      this.x = x;
      this.y = y;
      this.d = d;
      this.kleur = kleur;
      isGeselecteerd = false;
   }

   void tekenDamsteen() {
      ellipseMode(CORNER);
      fill(kleur);

      if (isGeselecteerd) {
         stroke(255, 0, 0);
      } else {
         noStroke();
      }

      ellipse(x, y, d, d);
   }
}

Damsteen d1;

void setup() {
   d1 = new Damsteen(0.0, 0.0, 20.0, 255);
}

void draw() {
   d1.tekenDamsteen();
}
</code></pre>
<p>Teken het geheugenmodel op het moment dat methode <code>tekenDamsteen()</code> wordt aangeroepen op de een na laatste regel</p>
<h2 id="l62-b"><a class="header" href="#l62-b">L6.2 B</a></h2>
<p>De methode <code>tekenDamsteen</code> wordt nu uit de klassedefinitie van <code>Damsteen</code> gehaald en opnieuw gedefinieerd als globale functie zoals hieronder te zien is:</p>
<pre><code class="language-java">class Damsteen {
   float x, y, d;
   int kleur;
   boolean isGeselecteerd;

   Damsteen(float x, float y, float d, int kleur) {
      this.x = x;
      this.y = y;
      this.d = d;
      this.kleur = kleur;
      isGeselecteerd = false;
   }
}

void tekenDamsteen(Damsteen steen) {
   ellipseMode(CORNER);
   fill(steen.kleur);

   if (steen.isGeselecteerd) {
      stroke(255, 0, 0);
   } else {
      noStroke();
   }

   ellipse(steen.x, steen.y, steen.d, steen.d);
}

Damsteen d1;

void setup() {
   d1 = new Damsteen(0.0, 0.0, 20.0, 255);
}

void draw() {
   tekenDamsteen(d1);
}
</code></pre>
<p>Teken opnieuw het geheugenmodel op het moment dat methode <code>tekenDamsteen()</code> wordt aangeroepen op de een na laatste regel</p>
<h2 id="l62-c"><a class="header" href="#l62-c">L6.2 C</a></h2>
<p>Versie A is beter dan versie B. Leg uit waarom.</p>
<h1 id="reflectieopgaven-1"><a class="header" href="#reflectieopgaven-1">Reflectieopgaven</a></h1>
<h1 id="opgave-l63---testen-van-een-klasse"><a class="header" href="#opgave-l63---testen-van-een-klasse">Opgave L6.3 - Testen van een klasse</a></h1>
<p>Bij sommige opgaven is er gevraagd om een test te schrijven voor een klasse. Geef een schets van de code die je maakt, als je een test voor een klasse schrijft.</p>
<h1 id="opgave-l64---functie--methode"><a class="header" href="#opgave-l64---functie--methode">Opgave L6.4 - Functie &lt;&gt; Methode</a></h1>
<p>Wat is de overeenkomst tussen een functie en een methode?</p>
<p>Wat is het verschil tussen een functie en een methode?</p>
<h1 id="opgave-l65---klassendiagrammen--geheugenmodel"><a class="header" href="#opgave-l65---klassendiagrammen--geheugenmodel">Opgave L6.5 - Klassendiagrammen &lt;&gt; Geheugenmodel</a></h1>
<p>Hoewel klassendiagrammen en geheugenmodellen beide informatie geven over het programma, is het soort informatie verschillend
Leg uit voor beide diagrammen uit welke informatie eruit te halen is en op welk moment in het ontstaan van het programma je het diagram kunt gebruiken. Gebruik daarbij zoveel mogelijk van onderstaande begrippen:</p>
<p><em>Toestand van een programma, overzicht, klassen, objecten, relatie, variabelen, ontwerp, runtime</em></p>
<h1 id="opgave-l66---opgaven-en-tags"><a class="header" href="#opgave-l66---opgaven-en-tags">Opgave L6.6 - Opgaven en tags</a></h1>
<h2 id="l66-a"><a class="header" href="#l66-a">L6.6 A</a></h2>
<p>Bekijk nogmaals elke opgave en bekijk welke opgaven je hebt gemaakt, welke opgaven je denkt te beheersen en van welke opgave je onderdelen nog niet begrijpt.</p>
<h2 id="l66-b"><a class="header" href="#l66-b">L6.6 B</a></h2>
<p>Bij elke opgave staan tags genoemd. Benoem de rol van elke tag in de opgave, of vraag dit na. Ga ook na of er een tag bij de opgave mist.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-7---voorbereiding-v7"><a class="header" href="#les-7---voorbereiding-v7">Les 7 - Voorbereiding (V7)</a></h1>
<h1 id="theorie-5"><a class="header" href="#theorie-5">Theorie</a></h1>
<h2 id="screencast-onderwerp-42----44-van-processing-naar-java"><a class="header" href="#screencast-onderwerp-42----44-van-processing-naar-java">Screencast onderwerp 4.2 -- 4.4 van Processing naar Java</a></h2>
<h3 id="onderwerp-42"><a class="header" href="#onderwerp-42">Onderwerp 4.2</a></h3>
<p><a href="https://www.youtube.com/watch?v=Ub-0Pa5B1Lw&amp;list=PLpd9jJvk1PjnMmrtlNeOzviLhJolx0_oi&amp;index=2">https://www.youtube.com/watch?v=Ub-0Pa5B1Lw&amp;list=PLpd9jJvk1PjnMmrtlNeOzviLhJolx0_oi&amp;index=2</a></p>
<h4 id="onderwerp-43"><a class="header" href="#onderwerp-43">Onderwerp 4.3</a></h4>
<p><a href="https://www.youtube.com/watch?v=guHGz_a1Z0w&amp;list=PLpd9jJvk1PjnMmrtlNeOzviLhJolx0_oi&amp;index=3">https://www.youtube.com/watch?v=guHGz_a1Z0w&amp;list=PLpd9jJvk1PjnMmrtlNeOzviLhJolx0_oi&amp;index=3</a></p>
<h4 id="onderwerp-44"><a class="header" href="#onderwerp-44">Onderwerp 4.4</a></h4>
<p><a href="https://www.youtube.com/watch?v=XQltRh1ba0g&amp;list=PLpd9jJvk1PjnMmrtlNeOzviLhJolx0_oi&amp;index=4">https://www.youtube.com/watch?v=XQltRh1ba0g&amp;list=PLpd9jJvk1PjnMmrtlNeOzviLhJolx0_oi&amp;index=4</a></p>
<h2 id="boek-3"><a class="header" href="#boek-3">Boek</a></h2>
<h3 id="hoofdstuk-2"><a class="header" href="#hoofdstuk-2">Hoofdstuk 2</a></h3>
<p>2.8 (pagina 68 t/m 70)</p>
<h3 id="hoofdstuk-6"><a class="header" href="#hoofdstuk-6">Hoofdstuk 6</a></h3>
<p>6.12 (pagina 239 t/m 242)</p>
<h2 id="processing-library-importeren-in-intellij--eclipse"><a class="header" href="#processing-library-importeren-in-intellij--eclipse">Processing library importeren in IntelliJ / Eclipse</a></h2>
<p>Om de Processing klassen te kunnen gebruiken in  IntelliJ of Eclipse, zul je deze eerst moeten importeren. Hoe je dit kan doen staat in het document <strong>Gebruik van Processing in Eclipse en IntelliJ.docx</strong>, te vinden op Onderwijs Online.</p>
<h1 id="opgave-v71---klok-in-eclipse"><a class="header" href="#opgave-v71---klok-in-eclipse">Opgave V7.1 - Klok in Eclipse</a></h1>
<h2 id="v71-a"><a class="header" href="#v71-a">V7.1 A</a></h2>
<p>Zet alle klassen uit de <code>KlokApp</code> in Processing om naar Javacode in IntelliJ / Eclipse.</p>
<p>(De Processing code staat op Onderwijs Online, zie Les 5: KlokApp.zip)</p>
<h2 id="v71-b"><a class="header" href="#v71-b">V7.1 B</a></h2>
<p>Zorg ervoor dat de klasse <code>Klok</code> geen instantievariabelen <code>x, y, hoogte</code> en <code>breedte</code> meer heeft. Maak in <code>Klok</code> wel getters en setters voor <code>x, y, hoogte</code> en <code>breedte</code> en zorg ervoor dat in die getters en setters de <code>urenTeller</code> en <code>minutenTeller</code> gebruikt worden om de juiste waarde terug te geven en aan te passen.</p>
<h1 id="opdracht-v72---klassediagram-chuck-a-luck"><a class="header" href="#opdracht-v72---klassediagram-chuck-a-luck">Opdracht V7.2 - Klassediagram Chuck-a-luck</a></h1>
<h2 id="spelbechrijving"><a class="header" href="#spelbechrijving">Spelbechrijving</a></h2>
<p>Beschouw de volgende eenvoudige versie van het spel Chuck-a-luck: Per ronde zet je een bedrag in op een geluksgetal van 1 tot 6 en vervolgens gooi je drie dobbelstenen met behulp van een dobbelbeker. Als geen van de dobbelstenen dit geluksgetal aangeeft, dan ben je je inzet kwijt. In alle andere gevallen wordt uitbetaald afhankelijk van het aantal dobbelstenen dat het voorspelde aantal ogen weergeeft:</p>
<div class="table-wrapper"><table><thead><tr><th>Overeenkomende dobbelstenen</th><th>Uitbetaling</th></tr></thead><tbody>
<tr><td>1 (een Single)</td><td>1:1</td></tr>
<tr><td>2 (een Double)</td><td>2:1</td></tr>
<tr><td>3 (een Triple)</td><td>10:1</td></tr>
</tbody></table>
</div>
<h2 id="technische-specificatie"><a class="header" href="#technische-specificatie">Technische specificatie</a></h2>
<h4 id="klassen"><a class="header" href="#klassen">Klassen</a></h4>
<p>De hele applicatie bestaat uit vier klassen: Dobbelsteen, Dobbelbeker en ChuckALuckSpel en MainApp. Zie onderstaande klassendiagram (meeste methoden en instantievariabelen zijn weggelaten).</p>
<p><img src="images/chuckaluck.png" alt="chuckaluckCD" /></p>
<h4 id="mainapp"><a class="header" href="#mainapp">MainApp</a></h4>
<p>De <code>MainApp</code> fungeert als een test voor de andere drie klassen. Hieronder is een mogelijke implementatie gegeven van de <code>MainApp</code>.</p>
<pre><code class="language-java">public class MainApp {

   public static void main(String[] args) {
   
      ChuckALuckSpel spel = new ChuckALuckSpel(100);
      
      spel.speelRonde(3, 5);
      System.out.println(spel);
      
      spel.speelRonde(3, 20);
      System.out.println(spel);
      
      spel.speelRonde(4, 10);
      System.out.println(spel);
   }
}
</code></pre>
<p>Deze code levert onderstaande uitvoer in de console:</p>
<pre><code>Ronde: 1
geluksgetal: 3
worp: 1 6 1
saldo: 95
---------------
Ronde: 2
geluksgetal: 3
worp: 2 6 5
saldo: 75
---------------
Ronde: 3
geluksgetal: 4
worp: 5 3 4
saldo: 85
---------------
</code></pre>
<h2 id=""><a class="header" href="#"></a></h2>
<h2 id="opgave"><a class="header" href="#opgave">Opgave</a></h2>
<p>Maak het klassendiagram af door in de drie klassen: <code>ChuckALuckSpel</code>, <code>Dobbelbeker</code> en <code>Dobbelsteen</code> alle ontbrekende instantievariabelen en methoden toe te voegen zodat ChuckALuck gespeeld kan worden op basis van bovenstaande beschrijving.
Probeer geen getters en setters te declareren tenzij je denkt dat je echt niet zonder kan in deze situatie.</p>
<h4 id="hint"><a class="header" href="#hint">Hint</a></h4>
<p>Je hoeft nog geen code te schrijven, dat doen we in de les.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-7---lesprogramma-l7"><a class="header" href="#les-7---lesprogramma-l7">Les 7 - Lesprogramma (L7)</a></h1>
<h1 id="opgave-l71---chuck-a-luck-implementeren"><a class="header" href="#opgave-l71---chuck-a-luck-implementeren">Opgave L7.1 - Chuck-a-luck implementeren</a></h1>
<p>Implementeer Chuck-a-luck op basis van de omschrijving uit de voorbereiding, het klassendiagram dat nabesproken is en alle klassen met stubs van de methoden (stubs zijn methodes zonder body).</p>
<h2 id="werkwijze"><a class="header" href="#werkwijze">Werkwijze</a></h2>
<h3 id="stap-1"><a class="header" href="#stap-1">Stap 1</a></h3>
<p>Werk in groepen van 6 personen en verdeel deze groepen in tweetallen. Elk tweetal is verantwoordelijk voor het maken van de implementatie en de tests van één klasse uit het Chuck-a-luck spel. Elk tweetal mag nog niet gebruik maken van de code van andere tweetallen.</p>
<h3 id="stap-2"><a class="header" href="#stap-2">Stap 2</a></h3>
<p>Voeg alle klassen pas bij elkaar nadat elk tweetal de implementatie van de klasse af heeft.</p>
<h3 id="stap-3-evalueer"><a class="header" href="#stap-3-evalueer">Stap 3: evalueer</a></h3>
<p>Ging het bij elkaar voegen van de klassen probleemloos?. Zo niet, waardoor werden de problemen veroorzaakt?</p>
<h1 id="oefeningen"><a class="header" href="#oefeningen">Oefeningen</a></h1>
<h1 id="opgave-l72---van-instantievariabele-naar-parameter"><a class="header" href="#opgave-l72---van-instantievariabele-naar-parameter">Opgave L7.2 - van instantievariabele naar parameter</a></h1>
<p>Hieronder is een gedeelte van de klasse <code>Teller</code> te zien zoals deze in de screencast is gemaakt.</p>
<pre><code class="language-java">public class Teller {
   private int maximum;
   private int waarde;
   private float x, y, breedte, hoogte;
   private KlokApp app;
   
   public Teller(KlokApp app, int maximum, float x, float y, float breedte) {
      this.maximum = maximum;
      waarde = 0;
      this.x = x;
      this.y = y;
      this.breedte = breedte;
      this.hoogte = breedte * 0.8f;
      this.app = app;
   }
   \...
   \...
   
   public void tekenTeller() {
      app.noStroke();
      app.fill(0);
      app.rectMode(app.CORNER);
      
      app.rect(x, y, breedte, hoogte);
      
      app.fill(255, 0, 0);
      app.textSize(hoogte);
      app.textAlign(app.LEFT);
      float tijdBreedte = app.textWidth(getTijdNotatie());
      float verschuivingX = (getBreedte() - tijdBreedte) / 2;
      float verschuivingY = app.textAscent() - app.textDescent() / 2;
      
      app.text(getTijdNotatie(), x + verschuivingX, y + verschuivingY);
   }
}
</code></pre>
<p>Als we de instantievariabele app veranderen in een parameter die we aan tekenTeller meegeven, dan krijgen we onderstaande code:</p>
<pre><code class="language-java">public class Teller {
   private int maximum;
   private int waarde;
   private float x, y, breedte, hoogte;
   
   public Teller(int maximum, float x, float y, float breedte) {
      this.maximum = maximum;
      waarde = 0;
      this.x = x;
      this.y = y;
      this.breedte = breedte;
      this.hoogte = breedte * 0.8f;
   }
   \...
   \...
   
   public void tekenTeller(KlokApp app) {
      app.noStroke();
      app.fill(0);
      app.rectMode(app.CORNER);
      
      app.rect(x, y, breedte, hoogte);
      
      app.fill(255, 0, 0);
      app.textSize(hoogte);
      app.textAlign(app.LEFT);
      float tijdBreedte = app.textWidth(getTijdNotatie());
      float verschuivingX = (getBreedte() - tijdBreedte) / 2;
      float verschuivingY = app.textAscent() - app.textDescent() / 2;
      
      app.text(getTijdNotatie(), x + verschuivingX, y + verschuivingY);
   }
}
</code></pre>
<h2 id="l72-a"><a class="header" href="#l72-a">L7.2 A</a></h2>
<p>Voer deze wijziging door in de klasse <code>Teller</code> en pas de code in <code>Klok</code> en <code>KlokApp</code> zo aan dat de code weer werkt.</p>
<h2 id="l72-b"><a class="header" href="#l72-b">L7.2 B</a></h2>
<p>Leg uit waar de voorkeur naar uit gaat: <code>app</code> als instantievariabele of een parameter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-8---voorbereiding-v8"><a class="header" href="#les-8---voorbereiding-v8">Les 8 - Voorbereiding (V8)</a></h1>
<h1 id="theorie-6"><a class="header" href="#theorie-6">Theorie</a></h1>
<h2 id="screencast-onderwerp-5-arraylist"><a class="header" href="#screencast-onderwerp-5-arraylist">Screencast onderwerp 5: ArrayList</a></h2>
<p><a href="http://www.youtube.com/playlist?list=PLpd9jJvk1PjmJddDbml4Yh_s99TUOJmtx">http://www.youtube.com/playlist?list=PLpd9jJvk1PjmJddDbml4Yh_s99TUOJmtx</a></p>
<h2 id="reader-over-uml-klassendiagrammen-en-sequentiediagrammen"><a class="header" href="#reader-over-uml-klassendiagrammen-en-sequentiediagrammen">Reader over uml klassendiagrammen en sequentiediagrammen</a></h2>
<p>Les 08 <em>Reader UML class en sequence diagrams</em></p>
<h2 id="boek-4"><a class="header" href="#boek-4">Boek</a></h2>
<h3 id="hoofdstuk-4-1"><a class="header" href="#hoofdstuk-4-1">Hoofdstuk 4</a></h3>
<p>4.1 tot en met 4.9 pagina 134 tot en met 154
4.11 pagina 161 tot en met 164</p>
<h1 id="opgave-v81---isbenedenscherm"><a class="header" href="#opgave-v81---isbenedenscherm">Opgave V8.1 - isBenedenScherm</a></h1>
<p>In de screencast 5.1 over arraylist op tijdstip 8:25 -- 8:40 wordt de methode <code>isBenedenScherm</code> aan het hoofdprogramma toegevoegd.
Kan deze methode niet beter in de klasse <code>Deeltje</code> staan? 
Leg uit waarom wel of niet. Moet je de methode dan nog aanpassen?
Gebruik in de uitleg het begrip: <u>verbergen van informatie]</u> / <u>information hiding]</u> (Boek 6.12, pagina 239 tot en met 242).</p>
<p>De code uit de screencast vindt je op Onderwijs Online.</p>
<h1 id="opgave-v82---for-lus-om-elementen-te-verwijderen"><a class="header" href="#opgave-v82---for-lus-om-elementen-te-verwijderen">Opgave V8.2 - for-lus om elementen te verwijderen</a></h1>
<h2 id="v82-a"><a class="header" href="#v82-a">V8.2 A</a></h2>
<p>Laat zien dat een for-lus die van 0 tot de grootte van de <code>ArrayList</code> loopt niet gebruikt kan worden om elementen te verwijderen.</p>
<p>Gebruik daarvoor het onderstaande programma en teken elke keer dat de tweede for lus doorlopen wordt (regel 8 tot en met 11) het geheugenmodel van de lijst. Zie de reader op #OnderwijsOnline (2.4 Geheugenmodel: Reader en extra oefeningen) om te zien hoe je een <code>ArrayList</code> tekent in het geheugenmodel.</p>
<pre><code class="language-java">01 public static void main(String[] args) {
02    ArrayList&lt;String&gt; lijst = new ArrayList&lt;String&gt;();
03
04    for (int i = 0; i &lt; 4; i++) {
05       lijst.add(&quot;element: &quot; + i);
06    }
07
08    for (int i = 0; i &lt; lijst.size(); i++) {
09       String s = lijst.get(i);
10       lijst.remove(s);
11    }
12 }
</code></pre>
<h2 id="v82-b"><a class="header" href="#v82-b">V8.2 B</a></h2>
<p>Hoe komt het dat in screencast 6.1 op tijdstip 9:00 toch alle <code>Deeltjes</code> uit de <code>ArrayList</code> worden verwijderd?</p>
<h2 id="v82-c"><a class="header" href="#v82-c">V8.2 C</a></h2>
<p>Maak een programma met for-lus die terug telt van de grootte van de <code>ArrayList</code> naar 0 en laat zien dat deze lus wel alle elementen uit de <code>ArrayList</code> verwijdert.</p>
<h1 id="opgave-v83---foreach-voor-verwijderen"><a class="header" href="#opgave-v83---foreach-voor-verwijderen">Opgave V8.3 - foreach voor verwijderen</a></h1>
<p>Maak een kort programmaatje waarmee je onderzoekt of je met een foreach lus alle elementen uit een <code>ArrayList</code> kunt verwijderen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-8---lesprogramma-l8"><a class="header" href="#les-8---lesprogramma-l8">Les 8 - Lesprogramma (L8)</a></h1>
<h1 id="opgave-l81---lottomachine"><a class="header" href="#opgave-l81---lottomachine">Opgave L8.1 - Lottomachine</a></h1>
<h2 id="functionele-specificatie"><a class="header" href="#functionele-specificatie">Functionele specificatie</a></h2>
<p>Een lottomachine (<a href="https://www.youtube.com/watch?v=ElQgz0gJwEo">https://www.youtube.com/watch?v=ElQgz0gJwEo</a>) bestaat uit een glazen bol die in de beginsituatie 45 balletjes bevat, genummerd van 1 tot en met 45. Verder heeft de lottomachine een 'scorebord' dat uit zeven glazen bestaat. Het besturingsgedeelte van de lottomachine brengt de bol in beweging en zorgt er voor dat er een balletje uit de glazen bol wordt geschept dat in het eerste glas valt. Vervolgens wordt er een tweede balletje uit de bol geschept dat in het tweede glas verdwijnt. Zo worden nog vier balletjes gekozen die in het derde tot en met zesde glas vallen. Het zevende en laatste balletje dat wordt getrokken komt in het zevende glas terecht; het nummer op dit balletje wordt het bonusgetal genoemd. Bij het presenteren van de uitslag worden de eerste zes balletjes die getrokken zijn van klein naar groot getoond.
De uitslag van een lottotrekking wordt bijvoorbeeld als volgt gepresenteerd: 
<code>4 11 15 27 31 40 bonusgetal: 18</code></p>
<h2 id="technische-specificatie-1"><a class="header" href="#technische-specificatie-1">Technische specificatie</a></h2>
<p>De lottoapplicatie gaat uit vier klassen bestaan: <code>Lottomachine</code>, <code>Glazenbol</code>, <code>Scorebord</code> en <code>Lottobal</code>. Een vijfde klasse <code>TestLottoApp</code> bevat de <code>main</code> methode en wordt gebruikt om de machine te testen.
Hieronder is een sequentiediagram te zien waarin de communicatie te zien is tussen de klassen gedurende een trekking. Let op: de methode <code>verzamelAlleBallen</code> is o.a. verantwoordelijk voor het aanmaken van de ballen .</p>
<p><img src="images/LottomachineSD.png" alt="lottomachineSD" /></p>
<p>Het poppetje links in het diagram representeert de klasse <code>TestLottoApp</code> (ook wel de Actor genoemd).</p>
<p>De implementatie van <code>Lottobal</code> staat hieronder weergegeven:</p>
<pre><code class="language-java">public class Lottobal {
   private int balNummer;
   
   public Lottobal(int nummer) {
      balNummer = nummer;
   }

   public boolean isNummerGroterDan(Lottobal andereBal) {
      return balNummer &gt; andereBal.balNummer;
   }

   public String toString() {
      return &quot;&quot; + balNummer;
   }
}
</code></pre>
<h2 id="l81-a"><a class="header" href="#l81-a">L8.1 A</a></h2>
<p>Maak een klassendiagram met daarin vier klassen (<code>Lottomachine</code>, <code>Glazenbol</code>, <code>Scorebord</code> en <code>Lottobal</code>) waaruit de lottoapplicatie bestaat. Gebruik het sequentiediagram en definitie van <code>Lottobal</code> om te bepalen welke methoden en attributen de klassen moeten hebben.</p>
<h2 id="l81-b"><a class="header" href="#l81-b">L8.1 B</a></h2>
<p>Maak op basis van het klassendiagram uit opgave A de klassendefinities en implementeer alvast de constructors in elke klasse.</p>
<h2 id="l81-c"><a class="header" href="#l81-c">L8.1 C</a></h2>
<p>Implementeer de overige methoden in elke klasse door het sequentiediagram van boven naar beneden af te lopen en elke methode te implementeren die je tegen komt.
Ga pas verder met een volgende methode als je de net geïmplementeerde methode getest hebt.</p>
<h4 id="hint-1"><a class="header" href="#hint-1">Hint 1</a></h4>
<p>In de methode <code>schepbal</code> moet je een willekeurige bal selecteren uit een verzameling ballen. Hiervoor heb je de klasse <code>Random</code> nodig. Zie boek 6.4.1 en 6.4.2 (op pagina 219 tot en met pagina 221) voor een beschrijving van deze klasse, of bekijk de Java-API-documentatie.</p>
<h4 id="hint-2"><a class="header" href="#hint-2">Hint 2</a></h4>
<p>Om de ballen op het scorebord te sorteren kun je de onderstaande code gebruiken:</p>
<pre><code class="language-java">public void sorteerBallen() {
   for (int i = ballen.size(); i &gt; 0; i--) {
      for (int j = 0; j &lt; i-1; j++) {
         if (ballen.get(j).getNummer() &gt; ballen.get(j+1).getNummer()) {
            Lottobal bal = ballen.get(j);
            ballen.set(j, ballen.get(j + 1));
            ballen.set(j + 1, bal);
         }
      }
   }
}
</code></pre>
<h2 id="l81-d"><a class="header" href="#l81-d">L8.1 D</a></h2>
<p>In het sorteeralgoritme uit opgave D staat dit statement.</p>
<p><code>if (ballen.get(j).getNummer() &gt; ballen.get(j+1).getNummer())</code></p>
<p>Deze regel zondigt tegen de (zeer zuivere) regel dat een klasse niets mag weten van de interne werking van een andere klasse. In dit geval weet <code>Scorebord</code> dat de klasse <code>Bal</code> integers gebruikt om het nummer bij te houden.
Pas de code in dit if-statement zo aan, dat er weer wordt voldaan aan de bovenstaande regel. Dit doe je door aan een bal te 'vragen' of hij groter is dan de meegegeven bal. Oftewel: maak een methode binnen <code>Bal</code> waar je een instantie van een <code>Bal</code> mee kunt geven en die retourneert of de bal een hoger nummer heeft of niet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-9---voorbereiding-v9"><a class="header" href="#les-9---voorbereiding-v9">Les 9 - Voorbereiding (V9)</a></h1>
<h1 id="theorie-7"><a class="header" href="#theorie-7">Theorie</a></h1>
<h2 id="screencast-onderwerp-6-static-en-final"><a class="header" href="#screencast-onderwerp-6-static-en-final">Screencast onderwerp 6: static en final</a></h2>
<p><a href="http://www.youtube.com/playlist?list=PLpd9jJvk1PjkmYIZ40sLe9deC81ILPIAy">http://www.youtube.com/playlist?list=PLpd9jJvk1PjkmYIZ40sLe9deC81ILPIAy</a></p>
<h1 id="opgave-v91---soorten-variabelen"><a class="header" href="#opgave-v91---soorten-variabelen">Opgave V9.1 - Soorten variabelen</a></h1>
<p>Gegeven onderstaande 4 begrippen. Zet de begrippen die hetzelfde betekenen bij elkaar.
Klasse variabele, instantievariabele, objectvariabele, statische variabele</p>
<h1 id="opgave-v92---print-in-main"><a class="header" href="#opgave-v92---print-in-main">Opgave V9.2 - Print in main?</a></h1>
<p>Om niet de hele tijd <code>System.out.println</code> te hoeven typen, wordt de onderstaande code bedacht.</p>
<pre><code class="language-java">public class PrintInMain {

   public static void main(String[] args) {
      print(&quot;hallo wereld&quot;);
   }

   public void print(String tekst) {
      System.out.println(tekst);
   }
}
</code></pre>
<p>Op regel 4 treedt dan de volgende foutmelding op.
<em>Cannot make a static reference to the non-static method print(String) from the type PrintInMain</em></p>
<h2 id="v92-a"><a class="header" href="#v92-a">V9.2 A</a></h2>
<p>Leg uit wat er met deze foutmelding bedoeld wordt.</p>
<h2 id="v92-b"><a class="header" href="#v92-b">V9.2 B</a></h2>
<p>Implementeer twee verschillende oplossingen voor deze foutmelding.</p>
<h2 id="v92-c"><a class="header" href="#v92-c">V9.2 C</a></h2>
<p>Welke oplossing verdient volgens jou de voorkeur.</p>
<h1 id="opgave-v93---student-uitbreiden"><a class="header" href="#opgave-v93---student-uitbreiden">Opgave V9.3 - Student uitbreiden</a></h1>
<p>Gegeven de code voor een student uit de screencast</p>
<pre><code class="language-java">public class Student {
   private String naam
   private String geslacht;

   public static final String MAN = &quot;man&quot;;
   public static final String VROUW = &quot;vrouw&quot;;

   private static int nStudenten = 0;

   public Student(String naam) {
      this.naam = naam;
      nStudenten++;
   }

   public String getGeslacht() {
      return geslacht;
   }

   public void setGeslacht(String geslacht) {
      this.geslacht = geslacht;
   }

   public static int getNStudenten() {
      return nStudenten;
   }

   public String toString() {
      return getNaam();
   }

   public String getNaam() {
      return naam;
   }

   public void setNaam(String naam) {
      this.naam = naam;
   }
}
</code></pre>
<h2 id="v93-a"><a class="header" href="#v93-a">V9.3 A</a></h2>
<p>Teken het geheugenmodel van onderstaande code op het moment dat het programma net voorbij regel 3 is. Bedenk met name waar de variabele <code>nStudenten</code> te vinden is.</p>
<pre><code class="language-java">public class DemoApp {
   public static void main(String[] args) {
      Student s = new Student(&quot;han&quot;);
      System.out.println(s.getNaam());
   }
}
</code></pre>
<h2 id="v93-b"><a class="header" href="#v93-b">V9.3 B</a></h2>
<p>Maak een nieuwe instantievariabele nummer die het studentennummer van een student kan bijhouden.</p>
<h2 id="v93-c"><a class="header" href="#v93-c">V9.3 C</a></h2>
<p>Hoewel er constanten zijn gemaakt, kan een gebruiker van de klasse <code>Student</code> nog steeds een geslacht meegeven met een andere waarde als &quot;man&quot;, of &quot;vrouw&quot;. Los dit probleem op.</p>
<h1 id="opgave-v94---enums"><a class="header" href="#opgave-v94---enums">Opgave V9.4 - Enums</a></h1>
<p>Het gebruik van constanten zoals dat in de klasse Student te zien is, kom je vaker tegen. Toch is er een betere manier om ervoor te zorgen dat het geslacht van een student slechts twee voorgedefinieerde waarden kan hebben. Daarvoor heb je een zogenaamde <code>Enum</code> nodig.</p>
<h2 id="v94-a"><a class="header" href="#v94-a">V9.4 A</a></h2>
<p>Zoek uit hoe je een <code>Enum</code> kunt gebruiken in Java en pas de klasse <code>Student</code> zo aan, dat er een <code>Enum</code> gebruikt wordt voor het geslacht.</p>
<h2 id="v94-b"><a class="header" href="#v94-b">V9.4 B</a></h2>
<p>Noem een voordeel van het gebruik van een <code>Enum</code> boven het gebruik van constanten.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-9---lesprogramma-l9"><a class="header" href="#les-9---lesprogramma-l9">Les 9 - Lesprogramma (L9)</a></h1>
<h1 id="opgave-l91---static-abc"><a class="header" href="#opgave-l91---static-abc">Opgave L9.1 - Static ABC</a></h1>
<p>Gegeven onderstaande 3 klassen (A, B en C):</p>
<pre><code class="language-java">public class A {
   private static String a = &quot;a&quot;;
   
   public static String getA() {
      return a;
   }
}

public class B {
   private static String b = &quot;b&quot;;

   public String getB() {
      return b;
   }
}

public class C {
   private String c = &quot;c&quot;;

   public static String getC() {
      return c;
   }
}
</code></pre>
<h2 id="l91-a"><a class="header" href="#l91-a">L9.1 A</a></h2>
<p>Welke klasse (A, B, of C) compileert niet?</p>
<h2 id="l91-b"><a class="header" href="#l91-b">L9.1 B</a></h2>
<p>Leg uit wat de reden voor deze foutmelding is?</p>
<h1 id="opgave-l92---studieadvies-i"><a class="header" href="#opgave-l92---studieadvies-i">Opgave L9.2 - Studieadvies I</a></h1>
<p>Gegeven de klasse <code>Student</code>. Een student heeft een naam en een cijferlijst met acht cijfers. Voor het gemak zijn de cijfers integers.</p>
<pre><code class="language-java">public class Student {
   private String naam;
   private int[] cijfers;
   
   public Student(String naam) {
      this.naam = naam;
      cijfers = new int[8];
   }

   public void setCijfer(int vaknummer, int cijfer) {
      cijfers[vaknummer] = cijfer;
   }

   public int[] getCijfers() {
      return cijfers;
   }

   public String toString() {
      String representatie = &quot;naam: &quot; + naam + &quot;\ncijfers: &quot;;
      for (int cijfer : cijfers) {
         representatie += &quot; &quot; + cijfer;
      }

      return representatie;
   }
}
</code></pre>
<p>De klasse <code>Studieadviseur</code> krijgt de verantwoordelijkheid te bepalen of een student een positief studieadvies krijgt.</p>
<p>Een student krijgt een positief studieadvies als er ten minste vier cijfers zijn die groter of gelijk zijn aan een 6.</p>
<p>Hieronder is de definitie van de klasse te vinden:</p>
<pre><code class="language-java">public class Studieadviseur {

   public static boolean krijgtPositiefStudieadvies(Student s) {

      //Implementatie moet je zelf maken, zie opgave

   }
}
</code></pre>
<p>Deze klasse kan met onderstaande code getest worden:</p>
<pre><code class="language-java">public class TestStudieadviesApp {

   public static void main(String\[\] args) {
      Random r = new Random();
      Student s1 = new Student(&quot;persoon 1&quot;);
      
      for (int i = 0; i &lt; 8; i++) {
         s1.setCijfer(i, r.nextInt(10) + 1);
      }
      
      System.out.println(s1);
      System.out.println(Studieadviseur.krijgtPositiefStudieadvies(s1));
      System.out.println(&quot;------------------&quot;);
   }
}
</code></pre>
<h2 id="l92-a"><a class="header" href="#l92-a">L9.2 A</a></h2>
<p>Implementeer de methode <code>krijgtPositiefStudieAdvies</code> in de klasse <code>Studieadviseur</code>.</p>
<h2 id="l92-b"><a class="header" href="#l92-b">L9.2 B</a></h2>
<p>Geef een reden waarom het een goede keuze is om de methode <code>krijgtPositiefStudieadvies</code> static te maken.</p>
<h2 id="l92-c"><a class="header" href="#l92-c">L9.2 C</a></h2>
<p>Het zou kunnen zijn dat de keuze om bovenstaande methode static te maken, niet in elke situatie een bruikbare keuze is. Verzin een situatie waarin de methode <code>krijgtPositiefStudieadvies</code> beter niet static kan zijn.</p>
<h1 id="opgave-l93---studieadvies-ii"><a class="header" href="#opgave-l93---studieadvies-ii">Opgave L9.3 - Studieadvies II</a></h1>
<p>Er wordt een klasse gemaakt waarmee studenten gegenereerd kunnen worden die een willekeurige cijferlijst hebben:</p>
<pre><code class="language-java">public class RandomStudentenGenerator {
   private Student[] studentenLijst;
   
   public static void genereerStudenten(int aantal) {
      Random generator = new Random();
      studentenLijst = new Student[aantal];
      
      for (int i = 0; i &lt; aantal; i++) {
         studentenLijst[i] = new Student(&quot;persoon_&quot; + i);
         for (int j = 0; j &lt; 8; j++) {
            studentenLijst[i].setCijfer(j, generator.nextInt(10) + 1);
         }
      }
   }

   public Student[] getStudentenLijst() {
      return studentenLijst;
   }
}
</code></pre>
<h2 id="l93-a"><a class="header" href="#l93-a">L9.3 A</a></h2>
<p>Plaats de code in je IDE en je krijgt (de bekende) foutmelding: <em>Cannot make a static reference to the non-static field studentenLijst</em>.</p>
<p>Leg uit wat er mis is.</p>
<h2 id="l93-b"><a class="header" href="#l93-b">L9.3 B</a></h2>
<p>Er zijn drie mogelijke oplossingen voor bovenstaande foutmelding:</p>
<h4 id="oplossing-i-static-toevoegen-op-twee-plekken"><a class="header" href="#oplossing-i-static-toevoegen-op-twee-plekken">Oplossing I: static toevoegen op twee plekken</a></h4>
<pre><code class="language-java">public class RandomStudentenGenerator {
   private static Student[] studentenLijst; //hier static toevoegen
   
   public static void genereerStudenten(int aantal) {
      Random generator = new Random();
      studentenLijst = new Student[aantal];
      
      for (int i = 0; i &lt; aantal; i++) {
         studentenLijst[i] = new Student(&quot;persoon_&quot; + i);
         for (int j = 0; j &lt; 8; j++) {
            studentenLijst[i].setCijfer(j, generator.nextInt(10) + 1);
         }
      }
   }

   public static Student[] getStudentenLijst() { // hier static toevoegen
      return studentenLijst;
   }
}
</code></pre>
<h4 id="oplossing-ii-static-verwijderen-bij-genereerstudenten"><a class="header" href="#oplossing-ii-static-verwijderen-bij-genereerstudenten">Oplossing II: static verwijderen bij genereerStudenten</a></h4>
<pre><code class="language-java">public class RandomStudentenGenerator {
   private Student[] studentenLijst;
   
   public void genereerStudenten(int aantal) { // hier static verwijderen
      Random generator = new Random();
      studentenLijst = new Student[aantal];
      
      for (int i = 0; i &lt; aantal; i++) {
         studentenLijst[i] = new Student(&quot;persoon_&quot; + i);
         for (int j = 0; j &lt; 8; j++) {
            studentenLijst[i].setCijfer(j, generator.nextInt(10) + 1);
         }
      }
   }

   public Student[] getStudentenLijst() {
      return studentenLijst;
   }
}
</code></pre>
<h4 id="oplossing-iii-instantievariabele-verwijderen-en-return-statement-toevoegen"><a class="header" href="#oplossing-iii-instantievariabele-verwijderen-en-return-statement-toevoegen">Oplossing III: instantievariabele verwijderen en return statement toevoegen</a></h4>
<pre><code class="language-java">public class RandomStudentenGenerator {
   
   public static Student[] genereerStudenten(int aantal) {
      Random generator = new Random();
      Student[] studentenLijst = new Student[aantal];
      
      for (int i = 0; i &lt; aantal; i++) {
         studentenLijst[i] = new Student(&quot;persoon_&quot; + i);
         for (int j = 0; j &lt; 8; j++) {
            studentenLijst[i].setCijfer(j, generator.nextInt(10) + 1);
         }
      }
      return studentenLijst;
   }
}
</code></pre>
<p>Leg uit welke oplossing je het meest aantrekkelijk vindt.</p>
<h1 id="uitdaging-1"><a class="header" href="#uitdaging-1">Uitdaging</a></h1>
<h1 id="opgave-l94---verkiezingsuitslag"><a class="header" href="#opgave-l94---verkiezingsuitslag">Opgave L9.4 - Verkiezingsuitslag</a></h1>
<p>Bij verkiezingen voor de Tweede Kamer wordt de zetelverdeling berekend met behulp van een bijzondere procedure, waarbij het vooral gaat om de verdeling van de zogenaamde restzetels. De procedure gaat zo, met voorbeelden uit de uitslag van de verkiezingen van 2010:</p>
<ul>
<li>Men berekent eerst het totale aantal stemmen (2010: 9.416.001) en deelt dit door 150, dit is de kiesdeler (2010: 62.773).</li>
<li>Elke partij krijgt een aantal zetels door het stemmenaantal van deze partij te delen door de kiesdeler en af te ronden naar beneden. De VVD kreeg in 2010 zo 30 volle zetels</li>
<li>Sommige partijen hebben minder stemmen dan de kiesdeler, ze 'halen de kiesdrempel niet'. Zij krijgen geen zetels en doen verder ook niet mee in de verdeling van de restzetels.</li>
<li>Omdat er naar beneden afgerond wordt en partijen de kiesdrempel niet halen, worden zo minder dan 150 zetels vergeven. De andere zetels - de restzetels - worden als volgt verdeeld:</li>
</ul>
<ol>
<li>Voor elke partij deelt men het aantal stemmen door het aantal zetels plus 1 (voor de VVD bereken je dus 1929575 / 31).</li>
<li>De partij met het grootste aantal stemmen per zetel krijgt een restzetel. (In 2010 kreeg de VVD de eerste restzetel) Voor die partij bereken je het aantal stemmen per zetel opnieuw (VVD: nu dus 1929575 / 32)</li>
<li>Je herhaalt de vorige stap totdat alle restzetels vergeven zijn.</li>
</ol>
<p>Let op! Het is niet goed genoeg om in één keer de volgorde van de aantallen stemmen per zetel af te gaan. Het kan namelijk gebeuren dat een grote partij eerder een tweede restzetel krijgt dan een andere, kleine partij. (Na het toekennen van de eerste restzetel daalt het aantal stemmen per zetel van de VVD tot ongeveer 60300, daardoor zou de VVD een tweede restzetel krijgen voor D66 de eerste krijgt.)</p>
<p>NB: De Nederlandse kieswet staat lijstverbindingen toe, waarbij twee of meer partijen bij elkaar genomen worden bij het verdelen van de restzetels. We laten deze buiten beschouwing.</p>
<p>Schrijf een programma dat de zetelverdeling berekent uitgaande van de aantallen stemmen per partij. Maak daarbij een ArrayList van 'PartijUitslagen', waarop je de procedure voor de zetelverdeling bij schrijft. Je hierbij gebruik maken van de startcode die op OnderwijsOnline staat: &quot;Verkiezingsuitslagen.zip&quot;. De startcode bevat de uitslagen van vijf verkiezingen (periode 1998-2010).</p>
<p><img src="images/verkiezingsuitslag.png" alt="verkiezing" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-10---voorbereiding-v10"><a class="header" href="#les-10---voorbereiding-v10">Les 10 - Voorbereiding (V10)</a></h1>
<h1 id="theorie-8"><a class="header" href="#theorie-8">Theorie</a></h1>
<h2 id="screencast-onderwerp-7-overerving"><a class="header" href="#screencast-onderwerp-7-overerving">Screencast onderwerp 7: Overerving</a></h2>
<p><a href="http://www.youtube.com/playlist?list=PLpd9jJvk1PjmlCr4hMlUwdLF9nJNtYVwv">http://www.youtube.com/playlist?list=PLpd9jJvk1PjmlCr4hMlUwdLF9nJNtYVwv</a></p>
<h2 id="boek-5"><a class="header" href="#boek-5">Boek</a></h2>
<h3 id="hoofdstuk-10"><a class="header" href="#hoofdstuk-10">Hoofdstuk 10</a></h3>
<p>10.1 t/m 10.6 pagina 370 t/m 391</p>
<h3 id="hoofdstuk-11"><a class="header" href="#hoofdstuk-11">Hoofdstuk 11</a></h3>
<p>11.5 pagina 413 en 414</p>
<p>11.9 pagina 420 t/m 422</p>
<h1 id="opgave-v101---overervingshiërarchie"><a class="header" href="#opgave-v101---overervingshiërarchie">Opgave V10.1 - Overervingshiërarchie</a></h1>
<h2 id="v101-a"><a class="header" href="#v101-a">V10.1 A</a></h2>
<p>Teken een overervingshiërarchie (boek pagina 384) waarin de onderstaande klassen elk één keer voorkomen (Kiwi staat er dus drie keer in).</p>
<p><code>Dier</code>, <code>Vogel</code>, <code>Levensvorm</code>, <code>Vrucht</code>, <code>Mens</code>, <code>Kiwi</code>, <code>Kiwi</code>, <code>Kiwi</code></p>
<p>Hint:</p>
<p><img src="images/kiwis.png" alt="kiwis" /></p>
<h2 id="v101-b"><a class="header" href="#v101-b">V10.1 B</a></h2>
<p>Implementeer de klassen <code>Vogel</code>, <code>Vrucht</code>, <code>Kiwi</code>  en <code>Kiwi</code> en los het naamconflict dat je krijgt op zonder de klassennamen van beide Kiwi's aan te passen (zie eventueel boek 6.5 pagina 224 en 225).</p>
<h1 id="opgave-v102---superconstructor"><a class="header" href="#opgave-v102---superconstructor">Opgave V10.2 - Superconstructor</a></h1>
<p>In deze opgave maken we alleen gebruik van de klasse <code>Dier</code> en de klasse <code>Kiwi</code>.</p>
<h2 id="v102-a"><a class="header" href="#v102-a">V10.2 A</a></h2>
<p>Bekijk de constructor van de klasse <code>Kiwi</code>. Wanneer deze constructor wordt uitgevoerd, wordt eerst de constructor van dier uitgevoerd. Geef de header (boek pagina 36) van deze constructor.</p>
<pre><code class="language-java">public class Dier {
   protected String naam;
}

public class Kiwi extends Dier {
   private int loopSnelheid;

   public Kiwi(String naam, int loopSnelheid) {
      this.loopSnelheid = loopSnelheid;
   }
}
</code></pre>
<h2 id="v102-b"><a class="header" href="#v102-b">V10.2 B</a></h2>
<p>De constructor die je bij opgave A hebt genoemd is niet expliciet gedefinieerd in de klasse <code>Dier</code>. Beschrijf zo exact mogelijk de spelregel die maakt dat deze constructor toch wordt uitgevoerd.</p>
<h2 id="v102-c"><a class="header" href="#v102-c">V10.2 C</a></h2>
<p>Er wordt een constructor toegevoegd aan de klasse <code>Dier</code>:</p>
<pre><code class="language-java">public class Dier {
   protected String naam;

   public Dier(String naam) {
      this.naam = naam;
   }
}
</code></pre>
<p>Nu geeft de constructor van <code>Kiwi</code> (regel 4) de foutmelding</p>
<p><em>Implicit super constructor Dier() is undefined. Must explicitly invoke another constructor</em></p>
<pre><code class="language-java">public class Kiwi extends Dier {
   private int loopSnelheid;

   public Kiwi(String naam, int loopSnelheid) {
      this.loopSnelheid = loopSnelheid;
   }
}
</code></pre>
<p>Leg uit wat deze foutmelding betekent.</p>
<h2 id="v102-d"><a class="header" href="#v102-d">V10.2 D</a></h2>
<p>De foutmelding uit opgave C kun je oplossen door onderstaande code:</p>
<pre><code class="language-java">public class Kiwi extends Dier {
   private int loopSnelheid;

   public Kiwi(String naam, int loopSnelheid) {
      super(naam);
      this.loopSnelheid = loopSnelheid;
   }
}
</code></pre>
<p>Onderzoek of je regels 5 en 6 ook mag omdraaien, zonder een foutmelding te krijgen.</p>
<h1 id="bronnen"><a class="header" href="#bronnen">Bronnen</a></h1>
<p>Wikimedia commons, 2015a. &quot;Apteryx owenii 1&quot; by G.D. Rowley - Rowley, G.D., Ornithological Miscellany, 1875-78 - http://www.nzbirds.com/birds/kiwils.html. Licensed under Publiek domein via Wikimedia Commons - https://commons.wikimedia.org/wiki/File:Apteryx_owenii_1.jpg#/media/File:Apteryx_owenii_1.jpg</p>
<p>Wikimedia commons, 2015b. &quot;Kiwi (Actinidia chinensis) 1 Luc Viatour&quot; by Luc Viatour - own work www.lucnix.beNikon case D300 optical Sigma 150mm F2,8 macro. Licensed under GFDL via Wikimedia Commons - https://commons.wikimedia.org/wiki/File:Kiwi_(Actinidia_chinensis)_1_Luc_Viatour.jpg#/media/File:Kiwi_(Actinidia_chinensis)_1_Luc_Viatour.jpg</p>
<p>Wikimedia commons, 2015c, &quot;John Key National Party2&quot; by Guo's - cropped from 2008-3-19 Mr John Key and Me.. Licensed under CC BY-SA 2.0 via Wikimedia Commons - https://commons.wikimedia.org/wiki/File:John_Key_National_Party2.jpg#/media/File:John_Key_National_Party2.jpg</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-10---lesprogramma-l10"><a class="header" href="#les-10---lesprogramma-l10">Les 10 - Lesprogramma (L10)</a></h1>
<h1 id="opgave-l101---vierkant-en-rechthoek"><a class="header" href="#opgave-l101---vierkant-en-rechthoek">Opgave L10.1 - Vierkant en rechthoek</a></h1>
<p><em>Discussieopgave.</em></p>
<p>Wat is de overervingsrelatie tussen een vierkant en een rechthoek. Erft een rechthoek van een vierkant of erft een vierkant van een rechthoek? Beargumenteer je keuze.</p>
<h1 id="opgave-l102---asiel"><a class="header" href="#opgave-l102---asiel">Opgave L10.2 - Asiel</a></h1>
<p>Gegeven onderstaande klassen:</p>
<pre><code class="language-java">public class Dier {
   protected String soort;

   public Dier(String soort) {
      this.soort = soort;
   }
}

public class Zoogdier extends Dier {
   protected int draagTijd;

   public Zoogdier(String soort, int draagTijd) {
      super(soort);
      this.draagTijd = draagTijd;
   }
}

public class Hond extends Zoogdier {
   private String naam;

   public Hond(String soort, int draagTijd, String naam) {
      super(soort, draagTijd);
      this.naam = naam;
   }
}
</code></pre>
<p>En de klasse met het hoofdprogramma:</p>
<pre><code class="language-java">public class Asiel {
   public static void main(String[] args) {
      Hond hond = new Hond(&quot;Canine&quot;, 2, &quot;Fiffie&quot;);
   }
}
</code></pre>
<h2 id="l102-a"><a class="header" href="#l102-a">L10.2 A</a></h2>
<p>Teken het geheugenmodel van dit programma op het moment dat in het hoofdprogramma de constructor van <code>Hond</code> is aangeroepen, in klasse <code>Hond</code> de aanroep van <code>super</code> wordt gedaan, in klasse <code>Zoogdier</code> de aanroep van <code>super</code> wordt gedaan en in klasse <code>Dier</code> de eerste regel van de constructor net is uitgevoerd.</p>
<p>Teken in het geheugenmodel alle stack frames vanaf de aanroep <code>new Hond()</code>, dus ook de constructors van de andere klassen. Volgens de reader Geheugenmodellen hebben alleen geinstantieerde objecten een plaats op de Heap, wel worden alle overgeërfde eigenschappen opgenomen.</p>
<h2 id="l102-b"><a class="header" href="#l102-b">L10.2 B</a></h2>
<p>Voeg aan de klassen <code>Dier</code>, <code>Zoogdier</code> en <code>Hond</code> een instantievariabele <code>engelseVertaling</code> toe.</p>
<p>Voeg drie println statements toe aan de constructor van de klasse Hond waarmee je de waarden van alle drie de variabelen engelseVertaling in de console laat zien. Lukt dit?</p>
<pre><code class="language-java">public class Dier {
   protected String soort;

   protected String engelseVertaling = &quot;Animal&quot;;

   public Dier(String soort) {
      this.soort = soort;
   }
}

public class Zoogdier extends Dier {

   protected int draagTijd;

   protected String engelseVertaling = &quot;Mammal&quot;;

   public Zoogdier(String soort, int draagTijd) {
      super(soort);
      this.draagTijd = draagTijd;
   }
}

public class Hond extends Zoogdier {

   protected String naam;

   protected String engelseVertaling = &quot;Dog&quot;;

   public Hond(String soort, int draagTijd, String naam) {
      super(soort, draagTijd);
      this.naam = naam;

      //hier print statements
   }
}
</code></pre>
<h1 id="opgave-l103---figuren-1"><a class="header" href="#opgave-l103---figuren-1">Opgave L10.3 - Figuren 1</a></h1>
<p>Gegeven de klassen <code>Cirkel</code> en <code>Rechthoek</code>:</p>
<pre><code class="language-java">import processing.core.PApplet;

public class Cirkel {

   private float x, y, vx, vy, ax, ay;
   private float diameter;
   private int kleur;

   public Cirkel(float x, float y, float diameter) {
      this.x = x;
      this.y = y;
      this.diameter = diameter;
      zetStil();
      kleur = 0xFFFFFFFF;
   }

   public void doeStap() {
      if (!staatStil()) {
         pasVersnellingToe();
         pasSnelheidToe();
      }
   }

   public void setSnelheid(float vx, float vy) {
      this.vx = vx;
      this.vy = vy;
   }

   public void setVersnelling(float ax, float ay) {
      this.ax = ax;
      this.ay = ay;
   }

   public void zetStil() {
      vx = vy = ax = ay = 0;
   }

   public boolean staatStil() {
      return (vx == 0 &amp;&amp; vy == 0 &amp;&amp; ax == 0 &amp;&amp; ay == 0);
   }

   public void tekenCirkel(PApplet p) {
      p.noStroke();
      p.fill(kleur);
      p.ellipse(x, y, diameter, diameter);
   }

   public void setKleur(int kleur) {
      this.kleur = kleur;
   }

   private void pasVersnellingToe() {
      vx += ax;
      vy += ay;
   }

   private void pasSnelheidToe() {
      x += vx;
      y += vy;
   }
}

import processing.core.PApplet;

public class Rechthoek {

   private float x, y, vx, vy, ax, ay;
   private float breedte, hoogte;
   private int kleur;

   public Rechthoek(float x, float y, float breedte, float hoogte) {
      this.x = x;
      this.y = y;
      this.breedte = breedte;
      this.hoogte = hoogte;
      zetStil();
      kleur = 0xFFFFFFFF;
   }

   public void doeStap() {
      if (!staatStil()) {
         pasVersnellingToe();
         pasSnelheidToe();
      }
   }

   public void setSnelheid(float vx, float vy) {
      this.vx = vx;
      this.vy = vy;
   }

   public void setVersnelling(float ax, float ay) {
      this.ax = ax;
      this.ay = ay;
   }

   public void zetStil() {
      vx = vy = ax = ay = 0;
   }

   public boolean staatStil() {
      return (vx == 0 &amp;&amp; vy == 0 &amp;&amp; ax == 0 &amp;&amp; ay == 0);
   }

   public void tekenRechthoek(PApplet p) {
      p.noStroke();
      p.fill(kleur);
      p.rect(x, y, breedte, hoogte);
   }

   public void setKleur(int kleur) {
      this.kleur = kleur;
   }

   private void pasVersnellingToe() {
      vx += ax;
      vy += ay;
   }

   private void pasSnelheidToe() {
      x += vx;
      y += vy;
   }
}
</code></pre>
<h2 id="l103-a"><a class="header" href="#l103-a">L10.3 A</a></h2>
<p>Maak een hoofdprogramma waarin je alle publieke methoden van <code>Cirkel</code> en <code>Rechthoek</code> test.</p>
<h2 id="l103-b"><a class="header" href="#l103-b">L10.3 B</a></h2>
<p>Verwijder alle gedupliceerde code door gebruik te maken van overerving. Pas de code in het hoofdprogramma niet aan en test of alles nog steeds werkt.</p>
<h2 id="l103-c"><a class="header" href="#l103-c">L10.3 C</a></h2>
<p>Voeg aan de superklasse die je in opgave B hebt gemaakt een variabele toe waarmee je kunt bijhouden of de figuur zichtbaar is of onzichtbaar. Maak een getter en setter voor deze variabele en gebruik deze variabele om de instanties van <code>Rechthoek</code> en <code>Cirkel</code> zichtbaar en onzichtbaar te maken. Test deze nieuwe mogelijkheid in het hoofdprogramma.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-11---voorbereiding-v11"><a class="header" href="#les-11---voorbereiding-v11">Les 11 - Voorbereiding (V11)</a></h1>
<h1 id="theorie-9"><a class="header" href="#theorie-9">Theorie</a></h1>
<p><strong>Screencast over onderwerp 8: statische en dynamische types en abstract</strong></p>
<p><a href="http://www.youtube.com/playlist?list=PLpd9jJvk1PjmbJnRN4kOfpYgKvJ2PCDsP">http://www.youtube.com/playlist?list=PLpd9jJvk1PjmbJnRN4kOfpYgKvJ2PCDsP</a></p>
<h2 id="boek-6"><a class="header" href="#boek-6">Boek</a></h2>
<h3 id="hoofdstuk-6-1"><a class="header" href="#hoofdstuk-6-1">Hoofdstuk 6</a></h3>
<p>6.10 pagina 234 t/m 236</p>
<h3 id="hoofdstuk-10-1"><a class="header" href="#hoofdstuk-10-1">Hoofdstuk 10</a></h3>
<p>10.6 t/m 10.10 pagina 390 t/m 400</p>
<h3 id="hoofdstuk-11-1"><a class="header" href="#hoofdstuk-11-1">Hoofdstuk 11</a></h3>
<p>11.1 t/m 11.4 pagina 404 t/m 413</p>
<p>11.6 t/m 11.12 pagina 414 t/m 427</p>
<h3 id="hoofdstuk-12"><a class="header" href="#hoofdstuk-12">Hoofdstuk 12</a></h3>
<p>12.3 en 12.4 , pagina 445 t/m 454 details van de code zijn niet belangrijk, zorg dat je de definities snapt</p>
<h1 id="opgave-v111---compile-time-vs-runtime"><a class="header" href="#opgave-v111---compile-time-vs-runtime">Opgave V11.1 - Compile-time vs Runtime</a></h1>
<p>Hieronder is een lijst van begrippen te vinden. Geef per begrip aan of ze gedurende compile-time of gedurende runtime een rol spelen.</p>
<ul>
<li>Abstract</li>
<li>Klasse</li>
<li>Instantie</li>
<li>Dynamische type</li>
<li>Statische type</li>
<li>Geheugenmodel</li>
<li>Methode look-up</li>
<li>Uitvoeren van een programma</li>
<li>Controleren van een programma</li>
</ul>
<h1 id="opgave-v112---geheugenmodel-knop"><a class="header" href="#opgave-v112---geheugenmodel-knop">Opgave V11.2 - Geheugenmodel Knop</a></h1>
<p>Hieronder is een gedeelte van een hoofdprogramma gegeven (<code>KnopApp</code>) en een deel van de klassen <code>Knop</code>, <code>Lichtknop</code> en <code>Licht</code>.  </p>
<pre><code class="language-java">01  public class KnopApp extends PApplet {
02     //code weggelaten
03     private Licht l;
04     private Knop k;
05
06     public void setup() {
07        l = new Licht(this);
08        k = new LichtKnop(this, l, 20, 20, 50, 50);
09        //code weggelaten
10     }
11     //code weggelaten
12  }

 
01  public class Knop {
02     protected PApplet app;
03     protected float x, y, breedte, hoogte;
04   
05     public Knop(PApplet app, float x, float y,  float breedte, float hoogte) {
06        this.app = app;
07        this.x = x;
08        this.y = y;
09        this.breedte = breedte;
10        this.hoogte = hoogte;
11    }
12       //code weggelaten
12  }


01  public class LichtKnop extends Knop {
02     private Licht licht;
03
04     public LichtKnop(PApplet app, Licht licht, float x, float y, float breedte, float hoogte) {
05         super(app, x, y, breedte, hoogte);
06         this.licht = licht;
07     }
08    
09     //code weggelaten
10  }

01  public class Licht {
02     private PApplet app;
03     private int kleur;
04
05     public Licht(PApplet app) {
06        this.app = app;
07        kleur = 0;
08     }
09     
10     //code weggelaten
11  }
</code></pre>
<p>Maak een geheugenmodel van het programma op het moment dat het statement op regel 8 (klasse <code>KnopApp</code>) net is uitgevoerd. Je hoeft de velden uit <code>LichtKnop</code> niet weer te geven.</p>
<h1 id="opgave-v113---asiel-2"><a class="header" href="#opgave-v113---asiel-2">Opgave V11.3 - Asiel 2</a></h1>
<p>Gegeven onderstaande klassen:</p>
<pre><code class="language-java">public class Dier{

   @Override
   public String toString() {
      return &quot;Dier&quot;; 
   }
}

public class Zoogdier extends Dier {

   @Override
   public String toString() {
      return &quot;Zoogdier&quot;;
   }
}

public class Hond extends Zoogdier {

   @Override
   public String toString() {
      return &quot;Hond&quot;;
   }
}
</code></pre>
<h2 id="v113-a"><a class="header" href="#v113-a">V11.3 A</a></h2>
<p>In de klasse <code>Dier</code> staat de annotatie <code>@Override</code> bij de methode <code>toString</code> waarmee gesuggereerd wordt dat deze methode in een superklasse van <code>Dier</code> bestaat en overschreven wordt. Erft de klasse <code>Dier</code> inderdaad van een andere klasse die de methode <code>toString</code> definieert, of kan de annotatie beter weggelaten worden?</p>
<h2 id="v113-b"><a class="header" href="#v113-b">V11.3 B</a></h2>
<p>Gegeven onderstaande hoofdprogramma:</p>
<pre><code class="language-java">01   public class Asiel2 {
02
03      public static void main(String[] args) {
04         Dier dier1 = new Dier();
05         Dier dier2 = new Zoogdier();
06         Dier dier3 = new Hond();
07
08         Zoogdier zoogdier1 = new Dier();
09         Zoogdier zoogdier2 = new Zoogdier();
10         Zoogdier zoogdier3 = new Hond();
11
12         Hond hond1 = new Dier();
13         Hond hond2 = new Zoogdier();
14         Hond hond3 = new Hond();
15
16         System.out.println(dier1.toString());
17         System.out.println(dier2.toString());
18         System.out.println(dier3.toString());
19
20         System.out.println(zoogdier1.toString());
21         System.out.println(zoogdier2.toString());
22         System.out.println(zoogdier3.toString());
23
24         System.out.println(hond1.toString());
25         System.out.println(hond2.toString());
26         System.out.println(hond3.toString());
27      }
28   }
</code></pre>
<p>Geef voor elk statement op regel 4 t/m 14 aan of ze door de compiler heenkomen, of dat er een foutmelding optreedt. Welk patroon zie je?</p>
<h2 id="v113-c"><a class="header" href="#v113-c">V11.3 C</a></h2>
<p>Geef voor elk statement op regel 16 t/m 26 aan uit welke klasse de methode <code>toString</code> komt die tijdens het uitvoeren van het programma gebruikt wordt. Sla uiteraard de regels over die vanwege eerdere compileerfouten niet kunnen worden uitgevoerd.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-11---lesprogramma-l11"><a class="header" href="#les-11---lesprogramma-l11">Les 11 - Lesprogramma (L11)</a></h1>
<h1 id="opgave-l111---casten-met-asiel-2"><a class="header" href="#opgave-l111---casten-met-asiel-2">Opgave L11.1 - Casten met Asiel 2</a></h1>
<p>De klassen <code>Dier</code>, <code>Zoogdier</code> en <code>Hond</code> zijn uitgebreid zoals hieronder is weergegeven.</p>
<pre><code class="language-java">public class Dier {
   protected String soort;
   protected String engelseVertaling = &quot;Animal&quot;;

   public Dier(String soort) {
      this.soort = soort;
   }

   public void adem() {
      System.out.println(&quot;adem in/adem uit&quot;);
   }

   public String toString() {
      return &quot;Dier&quot;;
   }
}

public class Zoogdier extends Dier {
   protected int draagTijd;
   protected String engelseVertaling = &quot;Mammal&quot;;

   public Zoogdier(String soort, int draagTijd) {
      super(soort);
      this.draagTijd = draagTijd;
   }

   public void zoog() {
      System.out.println(&quot;zoog&quot;);
   }

   @Override
   public String toString() {
      return &quot;Zoogdier&quot;;
   }
}

public class Hond extends Zoogdier {
   private String naam;
   protected String engelseVertaling = &quot;Dog&quot;;

   public Hond(String soort, int draagTijd, String naam) {
      super(soort, draagTijd);
      this.naam = naam;
   }

   public void blaf() {
      System.out.println(&quot;waf waf&quot;);
   }

   @Override
   public String toString() {
      return &quot;Hond&quot;;
   }
}

public class Asiel {
   public static void main(String[] args) {
      Dier dier1 = new Dier(&quot;Canine&quot;);
      Dier dier2 = new Zoogdier(&quot;Canine&quot;, 2);
      Dier dier3 = new Hond(&quot;Canine&quot;, 2, &quot;Fiffie&quot;);
      
      Zoogdier zoogdier2 = new Zoogdier(&quot;Canine&quot;, 3);
      Zoogdier zoogdier3 = new Hond(&quot;Canine&quot;, 3, &quot;Brutus&quot;);
      
      Hond hond3 = new Hond(&quot;Canine&quot;, 4, &quot;Pluto&quot; );
      
      //casts:
   }
}
</code></pre>
<h2 id="l111-a"><a class="header" href="#l111-a">L11.1 A</a></h2>
<p>Onderzoek in het programma Asiel 2 de of de onderstaande casts mogelijk zijn zonder een error op te leveren. Mocht je nog niet het boek erop nageslagen hebben, zoek dan eerst op hoe casten in zijn werk gaat in Java (zoekwoorden google: typecasting, java)</p>
<p>Downcasten (omlaag in de overervingshiërarchie):</p>
<ul>
<li>dier1 casten naar Hond</li>
<li>dier2 casten naar Hond</li>
<li>dier3 casten naar Hond</li>
<li>zoogdier2 casten naar Hond</li>
</ul>
<p>Upcasting (omhoog in de overervingshiërarchie):</p>
<ul>
<li>zoogdier2 casten naar Dier</li>
<li>zoogdier3 casten naar Dier</li>
<li>hond3 casten naar Zoogdier</li>
<li>hond3 casten naar Dier</li>
</ul>
<p>Ga als volgt te werk:</p>
<p>Implementeer de cast in het hoofdprogramma en controleer welke van de drie methoden <code>adem()</code>, <code>zoog()</code> en <code>blaf()</code> je IDE je nu toestaat aan te roepen (dus geen compilefouten geeft).</p>
<p>Run vervolgens het programma en controleer of je nu een runtime error krijgt.</p>
<h2 id="l111-b"><a class="header" href="#l111-b">L11.1 B</a></h2>
<p>Welke algemene conclusies kun je trekken op basis van dit experiment?</p>
<h3 id="l111-c"><a class="header" href="#l111-c">L11.1 C</a></h3>
<p>De runtime errors zijn te voorkomen door gebruik te maken van de operator <code>instanceof</code>. Zoek op hoe deze werkt en pas die toe op de regels die een runtime-fout opleveren.</p>
<h1 id="opgave-l112---figuren-2"><a class="header" href="#opgave-l112---figuren-2">Opgave L11.2 - Figuren 2</a></h1>
<p><em>Vervolg van <strong>Opgave L10.3 - Figuren 1</strong> uit les 10. Nu voegen we een abstracte klasse toe zoals ook in de screencast te zien is.</em></p>
<h2 id="l112-a"><a class="header" href="#l112-a">L11.2 A</a></h2>
<p>In de opgave Figuren 1 uit les 4-1 heb je de superklasse <code>Figuur</code> gemaakt om alle gedupliceerde code uit rechthoek en cirkel te verhelpen. Voeg aan deze klasse de abstracte methode <code>teken</code> toe en maak de klasse zelf ook abstract.</p>
<h2 id="l112-b"><a class="header" href="#l112-b">L11.2 B</a></h2>
<p>Vervang in <code>Cirkel</code> en <code>Rechthoek</code> de methoden <code>tekenCirkel</code> en <code>tekenRechthoek</code> door de methode <code>teken</code> en zorg dat dit een Override is van de abstracte methode uit de klasse <code>Figuur</code>.</p>
<h2 id="l112-c"><a class="header" href="#l112-c">L11.2 C</a></h2>
<p>Niet elk figuur hoeft te kunnen bewegen en daarom zou je kunnen overwegen om alle code die te maken heeft met snelheid en versnelling uit <code>Figuur</code> te halen en in een nieuwe klasse <code>BeweegbaarFiguur</code> te stoppen. Wanneer je dit doet, dan zou je ook een <code>BeweegbareCirkel</code> en een <code>BeweegbareRechthoek</code> moeten maken.
Teken een klassendiagram met <code>Figuur</code>, <code>BeweegbaarFiguur</code>, <code>Cirkel</code>, <code>Rechthoek</code>, <code>BeweegbareCirkel</code> , <code>BeweegbareRechthoek</code>. Van alle velden en methoden hoef je alleen de methoden <code>public void setKleur(int kleur)</code> , <code>public void doeStap()</code>, <code>public void setSnelheid()</code> en <code>public void teken(PApplet p)</code> op te nemen. Geef wel duidelijk aan welke methoden abstract zijn en welke niet.</p>
<h2 id="l112-d"><a class="header" href="#l112-d">L11.2 D</a></h2>
<p>De indeling die je in opgave C hebt getekend zorgt voor gedupliceerde code. Welke code ben je aan het dupliceren?</p>
<h2 id="l112-e"><a class="header" href="#l112-e">L11.2 E</a></h2>
<p>Zou je op basis van opgave C en D adviseren een onderscheid te maken in <code>Figuur</code> en <code>BeweegbaarFiguur</code>, of zou je alleen de klasse <code>Figuur</code> die ook alle code bevat om figuren te laten bewegen? Beargumenteer het antwoord.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-12---voorbereiding-v12"><a class="header" href="#les-12---voorbereiding-v12">Les 12 - Voorbereiding (V12)</a></h1>
<h1 id="theorie-10"><a class="header" href="#theorie-10">Theorie</a></h1>
<h2 id="screencast-over-onderwerp-9-complexe-overervingsstructuur"><a class="header" href="#screencast-over-onderwerp-9-complexe-overervingsstructuur">Screencast over onderwerp 9: Complexe overervingsstructuur</a></h2>
<p><a href="http://www.youtube.com/playlist?list=PLpd9jJvk1Pjk9_ObEgzxyHz_WfiY8BzxE">http://www.youtube.com/playlist?list=PLpd9jJvk1Pjk9_ObEgzxyHz_WfiY8BzxE</a></p>
<h2 id="boek-7"><a class="header" href="#boek-7">Boek</a></h2>
<h3 id="hoofdstuk-12-1"><a class="header" href="#hoofdstuk-12-1">Hoofdstuk 12</a></h3>
<p>12.5, pagina 454 t/m 457</p>
<h1 id="opgave-v121---switch-klassendiagram"><a class="header" href="#opgave-v121---switch-klassendiagram">Opgave V12.1 - Switch klassendiagram</a></h1>
<p>In de screencast wordt de code van de <code>KnoppenApp</code> geprogrammeerd.</p>
<p>Maak een klassendiagram met de klassen <code>Licht</code>, <code>Knop</code>, <code>Switch</code> en <code>LichtSwitch</code>. Je hoeft alleen de methoden <code>handelInteractieAf</code> en <code>doeKnopActie</code> op te nemen in het diagram. Geef wel duidelijk aan welke methoden abstract zijn en welke niet.</p>
<h1 id="opgave-v122---foutieve-toestand"><a class="header" href="#opgave-v122---foutieve-toestand">Opgave V12.2 - Foutieve toestand</a></h1>
<p>Wanneer je op de <code>LichtKnop</code> drukt en het licht aanzet dan komt de <code>LichtSwitch</code> in een foutieve toestand (d.w.z. als je naar de switch kijkt, krijg je de indruk dat het licht niet brandt (hij staat immers &quot;uit&quot;), terwijl het licht wel aan is). Zorg ervoor dat de <code>LichtSwitch</code> aan gaat als het licht via de <code>LichtKnop</code> aangezet wordt. Probeer zo effectief mogelijk gebruik te maken van de klassen die al gemaakt zijn. Gebruik de startcode die op #OnderwijsOnline gegeven is (hieruit is alles dat met <code>Geluid</code> te maken heeft verwijderd).</p>
<h1 id="opgave-v123---personenlijst-klassendiagram"><a class="header" href="#opgave-v123---personenlijst-klassendiagram">Opgave V12.3 - Personenlijst klassendiagram</a></h1>
<p>Gegeven onderstaande drie klassen</p>
<pre><code class="language-java">public class Persoon {
   protected String naam, voornaam;

   public Persoon(String naam, String voornaam) {
      this.naam = naam;
      this.voornaam = voornaam;
   }

   public String getNaam() {
      return naam;
   }

   public void setNaam(String naam) {
      this.naam = naam;
   }

   public String getVoornaam() {
      return voornaam;
   }

   public void setVoornaam(String voornaam) {
      this.voornaam = voornaam;
   }
}

public class Docent extends Persoon {
   protected String code;

   public Docent(String naam, String voornaam, String code) {
      super(naam, voornaam);
      this.code = code;
   }

   public String getCode() {
      return code;
   }

   public void setCode(String code) {
      this.code = code;
   }
}

public class Student extends Persoon {
   protected int nummer;
   protected Docent SLBer;

   public Student(String naam, String voornaam, int nummer, Docent SLBer) {
      super(naam, voornaam);
      this.nummer = nummer;
      this.SLBer = SLBer;
   }

   public int getNummer() {
      return nummer;
   }

   public void setNummer(int nummer) {
      this.nummer = nummer;
   }

   public Persoon getSLBer() {
      return SLBer;
   }

   public void setSLBer(Docent sLBer) {
      SLBer = sLBer;
   }
}
</code></pre>
<h2 id="opgave-1"><a class="header" href="#opgave-1">Opgave</a></h2>
<p>Maak een klassendiagram van deze code. De methoden uit de klassen hoef je er niet in op te nemen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-12---lesprogramma-l12"><a class="header" href="#les-12---lesprogramma-l12">Les 12 - Lesprogramma (L12)</a></h1>
<h1 id="opgave-l121---personenlijst-implementatie"><a class="header" href="#opgave-l121---personenlijst-implementatie">Opgave L12.1 - Personenlijst implementatie</a></h1>
<p>Gegeven onderstaande code en het klassendiagram dat je in de voorbereiding gemaakt hebt.</p>
<pre><code class="language-java">public class Persoon {
   protected String naam, voornaam;

   public Persoon(String naam, String voornaam) {
      this.naam = naam;
      this.voornaam = voornaam;
   }

   public String getNaam() {
      return naam;
   }

   public void setNaam(String naam) {
      this.naam = naam;
   }

   public String getVoornaam() {
      return voornaam;
   }

   public void setVoornaam(String voornaam) {
      this.voornaam = voornaam;
   }
}

public class Docent extends Persoon {
   protected String code;

   public Docent(String naam, String voornaam, String code) {
      super(naam, voornaam);
      this.code = code;
   }

   public String getCode() {
      return code;
   }

   public void setCode(String code) {
      this.code = code;
   }
}

public class Student extends Persoon {
   protected int nummer;
   protected Docent SLBer;

   public Student(String naam, String voornaam, int nummer, Docent SLBer) {
      super(naam, voornaam);
      this.nummer = nummer;
      this.SLBer = SLBer;
   }

   public int getNummer() {
      return nummer;
   }

   public void setNummer(int nummer) {
      this.nummer = nummer;
   }

   public Docent getSLBer() {
      return SLBer;
   }

   public void setSLBer(Docent sLBer) {
      SLBer = sLBer;
   }
}
</code></pre>
<h2 id="l121-a"><a class="header" href="#l121-a">L12.1 A</a></h2>
<p>In de klasse <code>Student</code> is een veld opgenomen met de naam SLBer en het type <code>Docent</code>. Dit veld wijst naar de docent die de SLBer is van de betreffende student. Nu zijn er bij AIM ook SLB'ers die geen docent zijn, dus we kunnen dit ontwerp niet handhaven. Kun je het type van het veld SLBer nu beter veranderen naar:</p>
<ol>
<li><code>String</code></li>
</ol>
<p>of</p>
<ol start="2">
<li><code>Persoon</code>?</li>
</ol>
<p>Beargumenteer beide opties.</p>
<h2 id="l121-b"><a class="header" href="#l121-b">L12.1 B</a></h2>
<p>Implementeer in elke klasse de methode <code>toString</code> (zie boek 11.7, pagina 415 t/m 418). Deze methode moet de naam en de waarde van elk veld uit de klasse teruggeven als <code>String</code>. De <code>toString</code> uit <code>Docent</code> en <code>Student</code> moet ook de naam en de waarde van elk veld uit de klasse <code>Persoon</code> teruggeven.</p>
<p>Genereer deze methoden met je IDE (<strong>IntelliJ</strong>: Code &gt; Generate... óf Alt-Insert; <strong>Eclipse</strong> : Source &gt; Generate toString()) en test de methoden in het hoofdprogramma.</p>
<h2 id="l121-c"><a class="header" href="#l121-c">L12.1 C</a></h2>
<p>Gegeven het onderstaande programma:</p>
<pre><code class="language-java">import java.util.ArrayList;

public class PersonenLijst {
   private ArrayList\&lt;Persoon\&gt; lijst;

   public PersonenLijst() {
      lijst = new ArrayList&lt;&gt;();
   }

   public ArrayList&lt;Student&gt; getSLBStudenten(Docent SLBer) {
      //TO DO
   }

   public static void main(String[] args) {
      PersonenLijst p = new PersonenLijst();

      Docent piet=new Docent(&quot;Piet&quot;, &quot;Jansen&quot;, &quot;jnsnp&quot;);

      Student marie=new Student(&quot;Marie&quot;, &quot;Pieters&quot;, 31415, piet);

      Student jan=new Student(&quot;Jan&quot;, &quot;de Vries&quot;, 92653, null); // nog geen SLB'er

      p.lijst.add(piet);

      p.lijst.add(marie);

      p.lijst.add(jan);

      // voeg zelf nog enkele docenten en studenten toe

      ArrayList&lt;Student&gt; studentenVanPiet=p.getSLBStudenten(piet);
   }
}
</code></pre>
<p>Implementeer de methode <code>getSLBStudenten</code> (regel 10). Deze methode krijgt een instantie van <code>Docent</code>c mee en retourneert een lijst van alle SLB-studenten. Test deze methode in <code>main</code> door de voorbeeldcode hierboven verder uit te breiden en de arraylist aan het einde te printen.</p>
<p>Hint: bij de implementatie kun je gebruik maken van de <code>instanceof</code> operator (boek 11.10, pagina 423) en van casten (boek pagina 10.7.5, pagina 396).</p>
<h1 id="opgave-l122---personenlijst-zonder-cast"><a class="header" href="#opgave-l122---personenlijst-zonder-cast">Opgave L12.2 - Personenlijst zonder cast</a></h1>
<p>Zoals op pagina 396 beschreven wordt is casten meestal onwenselijk. Door de klasse <code>Persoon</code> abstract te maken en een abstracte methode <code>getSLBer</code> te maken kunnen we van deze cast afkomen.</p>
<h2 id="l122-a"><a class="header" href="#l122-a">L12.2 A</a></h2>
<p>Implementeer deze oplossing en omschrijf zo exact mogelijk wat de consequentie is van deze beslissing.</p>
<h2 id="l122-b"><a class="header" href="#l122-b">L12.2 B</a></h2>
<p>Is deze oplossing wenselijk, of kunnen we beter gebruik maken van een cast. Beargumenteer het antwoord.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-13---voorbereiding-v13"><a class="header" href="#les-13---voorbereiding-v13">Les 13 - Voorbereiding (V13)</a></h1>
<h1 id="theorie-11"><a class="header" href="#theorie-11">Theorie</a></h1>
<h2 id="screencast-over-onderwerp-10-interfaces"><a class="header" href="#screencast-over-onderwerp-10-interfaces">Screencast over onderwerp 10: Interfaces</a></h2>
<p><a href="http://www.youtube.com/playlist?list=PLpd9jJvk1PjnR8YVs3ZsZtJoGbtJLSUV_">http://www.youtube.com/playlist?list=PLpd9jJvk1PjnR8YVs3ZsZtJoGbtJLSUV_</a></p>
<h2 id="boek-8"><a class="header" href="#boek-8">Boek</a></h2>
<h3 id="hoofdstuk-12-2"><a class="header" href="#hoofdstuk-12-2">Hoofdstuk 12</a></h3>
<p>12.6 t/m 12.9 pagina 458 t/m 469</p>
<h1 id="opgave-v131---het-woord-interface"><a class="header" href="#opgave-v131---het-woord-interface">Opgave V13.1 - Het woord Interface</a></h1>
<p>Bij het maken van (objectgeörienteerde) programma's komt de term &quot;interface&quot; geregeld voorbij. Geef drie mogelijke betekenissen van het woord &quot;interface&quot;.</p>
<h1 id="opgave-v132---meerdere-interfaces-implementeren"><a class="header" href="#opgave-v132---meerdere-interfaces-implementeren">Opgave V13.2 - Meerdere interfaces implementeren</a></h1>
<p>Zoals in de screencast wordt verteld, is het in Java niet toegestaan om van meerdere klasses te erven (&quot;multiple inheritance&quot; bestaat in Java niet), maar mag je wel meerdere interfaces implementeren en daarnaast zelfs nog van een klasse erven. Waarom is multiple inheritance wel een probleem, maar het implementeren van meerdere interfaces niet?</p>
<h1 id="opgave-v133---van-if-else-naar-interface"><a class="header" href="#opgave-v133---van-if-else-naar-interface">Opgave V13.3 - Van if-else naar Interface</a></h1>
<p>Gegeven een applicatie waarmee rechthoeken en cirkels getekend geplaatst en verwijderd kunnen worden.</p>
<pre><code class="language-java">import java.util.ArrayList;
import processing.core.PApplet;

public class TekenApp extends PApplet {

   public static void main(String[] args) {
      PApplet.main(&quot;week5.ifelsenaarinterface.TekenApp&quot;);
   }

   private ArrayList&lt;Figuur&gt; figurenLijst = new ArrayList&lt;&gt;();
   private String huidigGereedschap = &quot;selecteer&quot;;

   public void settings() {
      size(400, 400);
   }

   public void draw() {
      background(0);
      for (Figuur figuur : figurenLijst) {
         figuur.teken(this);
      }
   }

   public void mousePressed() {
      switch (huidigGereedschap) {

         case &quot;selecteer&quot;:
            System.out.println(&quot;s&quot;);
            break;

         case &quot;rechthoek&quot;:
            Rechthoek r = new Rechthoek( mouseX, mouseY, 50, 50);
            figurenLijst.add(r);
            break;

         case &quot;cirkel&quot;:
            Cirkel c = new Cirkel(mouseX, mouseY, 50);
            figurenLijst.add(c);
            break;

         case &quot;gum&quot;:
            for (int i = figurenLijst.size() - 1; i &gt;= 0; i--) {
               Figuur fig = figurenLijst.get(i);

               if (fig.isMuisBinnen(mouseX, mouseY)) {
                  figurenLijst.remove(i);
               }
            }
            break;
      }
   }

   public void keyReleased() {
      switch (key) {
         case 's':
            huidigGereedschap = &quot;selecteer&quot;;
            break;
            
         case 'r':
            huidigGereedschap = &quot;rechthoek&quot;;
            break;
            
         case 'c':
            huidigGereedschap = &quot;cirkel&quot;;
            break;
            
         case 'g':
            huidigGereedschap = &quot;gum&quot;;
            break;
      }
   }
}
</code></pre>
<p>Hoewel deze code werkt, is het uitbreiden ervan lastig. Het probleem zit hem in het switch-statement in de methode <code>mousePressed()</code>.</p>
<p>Zodra er een nieuw gereedschap toegevoegd moet worden, moet het gedrag van dit gereedschap toegevoegd worden op een onoverzichtelijk plek. Daarnaast moet de naam van dit gereedschap op meerdere plekken gebruikt, zonder dat de compiler kan controleren of die naam goed geschreven is.</p>
<p>In deze opgave ga je met behulp van een interface dit switch-statement wegwerken.</p>
<h2 id="v133-a"><a class="header" href="#v133-a">V13.3 A</a></h2>
<p>Hieronder is een klassendiagram te zien waarin een oplossing geboden wordt. Schrijf de code voor de interface <code>IGereedschap</code> en voor alle gereedschappen die deze interface implementeren. Verplaatst de code uit de <code>mousePressed</code> naar de juiste klassen.
<img src="images/gereedschapCD.png" alt="gereedschapCD" /></p>
<h2 id="v133-b"><a class="header" href="#v133-b">V13.3 B</a></h2>
<p>Verander in het hoofdprogramma de code uit <code>keyReleased()</code> en <code>mousPressed</code> zodanig dat er optimaal gebruik wordt gemaakt van alle gereedschapsklassen.</p>
<p>Als het goed is bestaat de code in <code>mousePressed()</code> na aanpassing uit slechts één regel. Overigens hoef je het switch-statement uit <code>keyReleased()</code> alleen aan te passen. Weg werken van dit statement is niet nodig</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-13---lesprogramma-l13"><a class="header" href="#les-13---lesprogramma-l13">Les 13 - Lesprogramma (L13)</a></h1>
<h1 id="opgave-l131---meerdere-doelwitten"><a class="header" href="#opgave-l131---meerdere-doelwitten">Opgave L13.1 - Meerdere doelwitten</a></h1>
<p>We starten met een programma dat lijkt op het programma uit de screencast, maar met een paar wijzigingen. Je vindt de startcode op OnderwijsOnline en het klassendiagram staat hieronder.</p>
<p><img src="images/meerderedoelwitten.png" alt="meerderedoelwitten" /></p>
<p>Een knop kan nu meerdere <code>IDoelwitten</code> bevatten. Zodra er op de knop geklikt wordt, moeten alle gekoppelde doelwitten de methode <code>schakel</code> aanroepen.</p>
<p>De klasse <code>Tekstraam</code> plaats een tekst op het scherm als de methode <code>schakel</code> aangeroepen wordt.</p>
<h2 id="l131-a"><a class="header" href="#l131-a">L13.1 A</a></h2>
<p>Implementeer deze klassen en laat zien dat het programma werkt door een instantie van <code>Licht</code> en <code>Tekstraam</code> aan een instantie van <code>Switch</code> te koppelen in het hoofdprogramma. Je kunt om te testen de gegeven code in de klasse <code>KnoppenApp</code> gebruiken: hierin wordt een switch gemaakt waaraan een instantie van <code>Licht</code> en een instantie van <code>Tekstraam</code> worden gekoppeld.</p>
<h2 id="l131-b"><a class="header" href="#l131-b">L13.1 B</a></h2>
<p>Voeg een tweede switch toe waaraan dezelfde instantie van <code>Licht</code> is gekoppeld als aan de switch uit opgave A. Wat voor probleem kan nu optreden?</p>
<h2 id="l131-c"><a class="header" href="#l131-c">L13.1 C</a></h2>
<p>Laat de klasse <code>Switch</code> de interface <code>IDoelwit</code> implementeren. Wat kun je nu realiseren?</p>
<h1 id="opdracht-l132---radioknoppen"><a class="header" href="#opdracht-l132---radioknoppen">Opdracht L13.2 - Radioknoppen</a></h1>
<p>In deze oefening gaan we de implementatie van een interface combineren met een associatie van dezelfde interface binnen één klasse. We bouwen verder op de code van de vorige opdracht.*</p>
<p>Gekoppelde radioknoppen zijn knoppen, waarvan er maar één tegelijkertijd aan kan staan.</p>
<p>Zie onderstaande screenshots voor een voorbeeld. Je ziet hierop steeds drie radioknoppen.</p>
<p><img src="images/radioknoppen.png" alt="radioknoppen" /></p>
<p>In deze opdracht ga je de klasse <code>Radioknop</code> implementeren door deze te laten erven van <code>Switch</code> en de interface <code>IDoelwit</code> (zie vorige opgave) te laten implementeren. Zie onderstaand klassendiagram.</p>
<p><img src="images/radioknoppenCD.png" alt="radioknoppenCD" /></p>
<h2 id="l132-a"><a class="header" href="#l132-a">L13.2 A</a></h2>
<p>Leg uit welke mogelijkheden <code>Radioknop</code> krijgt door:</p>
<ul>
<li>te erven van <code>Switch</code></li>
<li>de interface <code>IDoelwit</code> te implementeren</li>
</ul>
<h2 id="l132-b"><a class="header" href="#l132-b">L13.2 B</a></h2>
<p>Implementeer de klasse <code>Radioknop</code> volgens bovenstaande specificatie. De <code>teken()</code> methode van <code>IDoelwit</code> heb je in deze opgave niet nodig en kun je weglaten. Voor de methoden <code>tekenKnop</code> en <code>isMuisOverKnop</code> in deze klasse, kun je onderstaande code gebruiken</p>
<pre><code class="language-java">@Override
public void tekenKnop() {
   app.ellipseMode(PApplet.CENTER);
   app.noStroke();
   app.fill(255);
   app.ellipse(x, y, breedte, hoogte);

   if (isAan) {
      app.fill(0);
      app.ellipse(x, y, breedte - breedte / 4, hoogte - hoogte / 4);
   }
}

@Override
public boolean isMuisOverKnop() {
   if (PApplet.dist(app.mouseX, app.mouseY, x, y) &lt; breedte / 2) {
      return true;
   }
   else {
      return false;
   }
}
</code></pre>
<h2 id="l132-c"><a class="header" href="#l132-c">L13.2 C</a></h2>
<p>Test de klassen in het hoofdprogramma door een <code>ArrayList</code> met drie instanties van <code>RadioKnop</code> te maken. Uiteraard moet je voor elke radioknop de andere twee radioknoppen als doelwit toevoegen. Zorg dat er in totaal drie radioknoppen in het hoofdprogramma zijn die allen aan elkaar gekoppeld zijn (d.w.z. dat van elk van de drie radioknoppen de twee andere radioknoppen als doelwit zijn toegevoegd).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-14---voorbereiding-v14"><a class="header" href="#les-14---voorbereiding-v14">Les 14 - Voorbereiding (V14)</a></h1>
<h1 id="theorie-12"><a class="header" href="#theorie-12">Theorie</a></h1>
<p>Geen nieuwe theorie</p>
<h1 id="oefeningen-1"><a class="header" href="#oefeningen-1">Oefeningen</a></h1>
<p>Voor de rest van de opleiding (en de toets) is het belangrijk dat je de theoretische concepten snapt van de code die je schrijft. Vandaar hieronder een aantal vragen.</p>
<h3 id="overerving"><a class="header" href="#overerving">Overerving</a></h3>
<p>a.  Beschrijf in je eigen woorden wat overerving is.</p>
<p>b.  Noem twee voordelen van het gebruik van overerving.</p>
<p>c.  Beschrijf in je eigen woorden wat een constructor is.</p>
<p>d.  Waarom hoef je niet verplicht een constructor te schrijven in iedere klasse?</p>
<h3 id="polymorfie"><a class="header" href="#polymorfie">Polymorfie</a></h3>
<p>a.  Beschrijf in je eigen woorden wat polymorfie is.</p>
<p>b.  Wat zijn de verschillen tussen een abstracte klasse en een interface?</p>
<p>c.  Wanneer kun je beter een abstracte klasse gebruiken en wanneer een interface?</p>
<h3 id="casting"><a class="header" href="#casting">Casting</a></h3>
<p>a.  Beschrijf in je eigen woorden wat casting is.</p>
<p>b.  Geef een reden om casting toe te passen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-14---lesprogramma-l14"><a class="header" href="#les-14---lesprogramma-l14">Les 14 - Lesprogramma (L14)</a></h1>
<h2 id="opgave-l141---terugblik"><a class="header" href="#opgave-l141---terugblik">Opgave L14.1 - Terugblik</a></h2>
<p><em>Klassikaal</em></p>
<h3 id="l141-a"><a class="header" href="#l141-a">L14.1 A</a></h3>
<h3 id="welke-nieuwe-begrippen-heb-je-geleerd-vanaf-les-7"><a class="header" href="#welke-nieuwe-begrippen-heb-je-geleerd-vanaf-les-7">Welke nieuwe begrippen heb je geleerd vanaf les 7?</a></h3>
<p>In drie weken heb je veel nieuwe begrippen geleerd en tevens geleerd hoe je dit moet toepassen.</p>
<p>Benoem deze begrippen en geef aan wat ze betekenen en hoe je deze toepast.</p>
<h3 id="l141-b"><a class="header" href="#l141-b">L14.1 B</a></h3>
<h3 id="hoe-tekenen-we-overerving-in-een-geheugenmodel"><a class="header" href="#hoe-tekenen-we-overerving-in-een-geheugenmodel">Hoe tekenen we overerving in een geheugenmodel?</a></h3>
<p>Beschrijf of we superklassen opnemen in een geheugenmodel. Waarom wel of waarom niet? Geef een voorbeeld.</p>
<h2 id="opgave-l142---starten-spellen-met-een-knop-of-switch"><a class="header" href="#opgave-l142---starten-spellen-met-een-knop-of-switch">Opgave L14.2 - Starten spellen met een knop of switch</a></h2>
<p>Individueel oefenen</p>
<h3 id="l142-a"><a class="header" href="#l142-a">L14.2 A</a></h3>
<h3 id="start-chuckaluck-vanuit-de-knoppenapp"><a class="header" href="#start-chuckaluck-vanuit-de-knoppenapp">Start chuckaluck vanuit de knoppenApp.</a></h3>
<p>Gebruik hiervoor de aangepaste doelwitten applicatie uit de vorige les.</p>
<h3 id="l142-b"><a class="header" href="#l142-b">L14.2 B</a></h3>
<h3 id="start-de-lottomachine-vanuit-de-knoppenapp"><a class="header" href="#start-de-lottomachine-vanuit-de-knoppenapp">Start de lottomachine vanuit de knoppenApp</a></h3>
<p>Wat valt je op als je dit hebt gedaan?</p>
<h2 id="extra-oefeningen-4"><a class="header" href="#extra-oefeningen-4">Extra oefeningen</a></h2>
<p>Zie het document 'les 14 extra oefeningen' op Onderwijs Online.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-15---voorbereiding-v15"><a class="header" href="#les-15---voorbereiding-v15">Les 15 - Voorbereiding (V15)</a></h1>
<h1 id="vragen-stellen"><a class="header" href="#vragen-stellen">Vragen stellen</a></h1>
<p>In de les gaan we de oefentoets maken en is er ruimte voor het beantwoorden van allerhande vragen over OOPD (ter voorbereiding op de echte toets). Om het behandelen van de vragen zo nuttig mogelijk te maken, voer je de volgende opdracht uit:</p>
<ul>
<li>Bereid <em>minimaal</em> 3 vragen voor over de OOPD-stof die je graag behandeld wil hebben in de les. Maak de vragen zo concreet mogelijk. Lever ze bij je docent in op de gebruikelijke manier.</li>
</ul>
<h1 id="voorbereiden-voor-eindopdracht"><a class="header" href="#voorbereiden-voor-eindopdracht">Voorbereiden voor eindopdracht</a></h1>
<p>Maak een start met de voorbereiding, tijdens de les ga je hier mee verder.
Voor de eindopdracht maken we gebruik van een door AIM ontwikkelde game engine Yaeger (<a href="https://github.com/han-yaeger">https://github.com/han-yaeger</a>)
Ga aan de slag met de tutorial, <a href="https://han-yaeger.github.io/yaeger-tutorial/introduction.html">https://han-yaeger.github.io/yaeger-tutorial/introduction.html</a>, om de game-engine in Eclipse of IntelliJ op te zetten en vervolgens te leren hoe je hiermee je game kunt ontwikkelen.</p>
<p>Lees ook de manual door:
<a href="https://han-yaeger.github.io/yaeger/book/">https://han-yaeger.github.io/yaeger/book/</a></p>
<p>Om een idee te krijgen welke features er allemaal in Yaeger zitten kun je de Showcase bekijken:
<a href="https://github.com/han-yaeger/yaeger-showcase">https://github.com/han-yaeger/yaeger-showcase</a></p>
<p>Hou hier rekening mee wanneer je een eigen game gaat bedenken. Heb je features nodig die niet in de showcase voorkomen, check dan even bij je docent of het mogelijk is. Yaeger is nog steeds in ontwikkeling en er worden voortdurend nieuwe features toegevoegd.</p>
<p>Als de packages in Eclipse er zo uitzien als in de afbeelding hieronder (alle packages onder elkaar) en je dat onprettig vindt, kun je ervoor kiezen om de manier waarop packages worden weergegeven aan te passen. Doe dat door op het kleine naar beneden wijzende pijltje boven de mappenstructuur te klikken, te kiezen voor &quot;Package representation&quot; en vervolgens &quot;Hierarchical&quot;.</p>
<p><img src="images/packageseclipse.png" alt="packageseclipse" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-15---lesprogramma-l15"><a class="header" href="#les-15---lesprogramma-l15">Les 15 - Lesprogramma (L15)</a></h1>
<h1 id="les"><a class="header" href="#les">Les</a></h1>
<p>In deze les wordt geoefend met een schriftelijke voorbeeldtoets en ga je verder met de Yaeger tutorial.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
